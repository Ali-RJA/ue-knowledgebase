<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UE5 Combat Architecture Bible v2 - Ultra-Comprehensive Reference</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 50%, #0f0f23 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #e0e0e0;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            padding: 30px 20px;
            background: rgba(255,255,255,0.05);
            border-radius: 16px;
            margin-bottom: 30px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .header h1 {
            font-size: 2.5rem;
            background: linear-gradient(90deg, #61dafb, #bb86fc, #03dac6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }
        
        .header p {
            color: #888;
            font-size: 1.1rem;
        }
        
        .version-badge {
            display: inline-block;
            background: linear-gradient(90deg, #f39c12, #e74c3c);
            color: #fff;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.8rem;
            margin-top: 10px;
            font-weight: bold;
        }
        
        .legend {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255,255,255,0.03);
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.08);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            flex-shrink: 0;
        }
        
        .legend-text {
            font-size: 0.85rem;
        }
        
        .diagram-container {
            background: rgba(255,255,255,0.02);
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.08);
            overflow: hidden;
            position: relative;
            height: 80vh;
            cursor: grab;
            user-select: none;
        }
        
        .diagram-container:active {
            cursor: grabbing;
        }
        
        .diagram-canvas {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            will-change: transform;
        }
        
        .mermaid {
            display: inline-block;
            padding: 30px;
        }
        
        .mermaid svg {
            display: block;
        }
        
        .zoom-indicator {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(0,0,0,0.7);
            color: #61dafb;
            padding: 8px 14px;
            border-radius: 6px;
            font-size: 0.85rem;
            pointer-events: none;
            z-index: 10;
        }
        
        .canvas-hint {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0,0,0,0.7);
            color: #888;
            padding: 8px 14px;
            border-radius: 6px;
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 10;
            opacity: 0.8;
        }
        
        .footer {
            text-align: center;
            padding: 20px;
            margin-top: 30px;
            color: #666;
            font-size: 0.9rem;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .control-btn {
            padding: 10px 20px;
            background: rgba(97, 218, 251, 0.1);
            border: 1px solid #61dafb;
            color: #61dafb;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }
        
        .control-btn:hover {
            background: rgba(97, 218, 251, 0.2);
            transform: translateY(-2px);
        }
        
        .quick-ref {
            margin-top: 40px;
            padding: 25px;
            background: rgba(255,255,255,0.03);
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.08);
        }
        
        .quick-ref h2 {
            color: #61dafb;
            margin-bottom: 20px;
            font-size: 1.5rem;
        }
        
        .ref-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
        }
        
        .ref-card {
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid;
        }
        
        .ref-card h3 {
            margin-bottom: 5px;
            font-size: 1.1rem;
        }
        
        .ref-card .file-path {
            font-size: 0.75rem;
            color: #888;
            margin-bottom: 10px;
            font-family: monospace;
        }
        
        .ref-card pre {
            background: rgba(0,0,0,0.4);
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
            font-size: 0.8rem;
            line-height: 1.5;
        }
        
        .ref-card code {
            color: #03dac6;
        }
        
        .ref-card.delegate { border-color: #f39c12; }
        .ref-card.delegate h3 { color: #f39c12; }
        
        .ref-card.struct { border-color: #e74c3c; }
        .ref-card.struct h3 { color: #e74c3c; }
        
        .ref-card.pattern { border-color: #8bc34a; }
        .ref-card.pattern h3 { color: #8bc34a; }
        
        .ref-card.memory { border-color: #bb86fc; }
        .ref-card.memory h3 { color: #bb86fc; }
        
        .ref-card.notify { border-color: #9b59b6; }
        .ref-card.notify h3 { color: #9b59b6; }
        
        .ref-card.trace { border-color: #e74c3c; }
        .ref-card.trace h3 { color: #e74c3c; }
        
        .ref-card.health { border-color: #e91e8b; }
        .ref-card.health h3 { color: #e91e8b; }
        
        .ref-card.network { border-color: #00bcd4; }
        .ref-card.network h3 { color: #00bcd4; }
        
        .ref-card.debug { border-color: #ffd93d; }
        .ref-card.debug h3 { color: #ffd93d; }
        
        .ref-card.damage { border-color: #ff5722; }
        .ref-card.damage h3 { color: #ff5722; }
        
        .section-divider {
            text-align: center;
            margin: 30px 0;
            color: #61dafb;
            font-size: 1.2rem;
        }
        
        /* Puzzle Tag Styles - Lego Piece References */
        .puzzle-tag {
            display: inline-flex;
            align-items: center;
            float: right;
            margin-left: 12px;
            padding: 1px 6px;
            background: rgba(187, 134, 252, 0.15);
            border: 1px solid rgba(187, 134, 252, 0.4);
            border-radius: 3px;
            font-size: 0.65rem;
            font-family: 'Segoe UI', sans-serif;
            color: #bb86fc;
            text-decoration: none;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.7;
        }
        
        .puzzle-tag:hover {
            opacity: 1;
            background: rgba(187, 134, 252, 0.25);
            border-color: #bb86fc;
            transform: translateY(-1px);
        }
        
        .puzzle-tag::before {
            content: 'ğŸ§©';
            font-size: 0.55rem;
            margin-right: 3px;
        }
        
        .ref-card pre {
            position: relative;
        }
        
        .code-line {
            display: block;
            position: relative;
        }
        
        .code-line .puzzle-tag {
            position: absolute;
            right: 0;
            top: 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>âš”ï¸ UE5 Combat Architecture Bible</h1>
        <p>Ultra-Comprehensive C++ Combat System Reference | With Extended Notes & Networking</p>
        <div class="version-badge">V2.0 - Enhanced with Q&A, Debug, Multiplayer Patterns</div>
    </div>
    
    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background: #9b59b6;"></div>
            <span class="legend-text"><strong>Asset Domain</strong> - Editor-authored data</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #3498db;"></div>
            <span class="legend-text"><strong>Animation Runtime</strong> - Notify execution</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #f39c12;"></div>
            <span class="legend-text"><strong>Timing Gatekeeper</strong> - Delegate bridge</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #27ae60;"></div>
            <span class="legend-text"><strong>Actor Coordinator</strong> - Command center</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #e74c3c;"></div>
            <span class="legend-text"><strong>Physics Query</strong> - World traces</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #e91e8b;"></div>
            <span class="legend-text"><strong>State Management</strong> - Health component</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #00bcd4;"></div>
            <span class="legend-text"><strong>Native Responders</strong> - C++ systems</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #8bc34a;"></div>
            <span class="legend-text"><strong>Cosmetic Responders</strong> - BP/Art layer</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff9800; border: 2px dashed #ff9800;"></div>
            <span class="legend-text"><strong>ğŸ“ NOTES</strong> - Extended Q&A / Code / Gotchas</span>
        </div>
    </div>
    
    <div class="controls">
        <button class="control-btn" onclick="zoomIn()">ğŸ” Zoom In</button>
        <button class="control-btn" onclick="zoomOut()">ğŸ” Zoom Out</button>
        <button class="control-btn" onclick="resetZoom()">â†º Reset</button>
        <button class="control-btn" onclick="downloadSVG()">â¬‡ Download SVG</button>
    </div>
    
    <div class="diagram-container" id="diagram-container">
        <div class="canvas-hint">ğŸ–±ï¸ Scroll to zoom â€¢ Drag to pan â€¢ NOTES boxes contain extended info</div>
        <div class="zoom-indicator" id="zoom-indicator">100%</div>
        <div class="diagram-canvas" id="diagram-canvas">
            <div class="mermaid" id="mermaid-diagram">
flowchart TB
    direction TB

    %% ============================================================
    %% LAYER 0: ASSET DOMAIN
    %% ============================================================
    subgraph LAYER0["ğŸ“ LAYER 0: ASSET DOMAIN â”â” Authored in Editor"]
        direction TB
        
        subgraph MONTAGE["UAnimMontage Asset"]
            direction TB
            MONTAGE_DEF["<b>UAnimMontage</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>â€¢ Composite animation asset<br/>â€¢ Contains notify tracks<br/>â€¢ Defines sections/slots"]
            
            NOTIFY_TRACK["<b>Notify Track</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Frame 0 â•â•â•â•â•â•â•â•â•â• Frame N<br/>         â–² notify fires"]
            
            MONTAGE_DEF --> NOTIFY_TRACK
        end
        
        subgraph NOTIFY_DEF["UAnimNotify Subclass"]
            NOTIFY_CLASS["<b>UAnimNotify_OpenHitWindow</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>UPROPERTY parameters:<br/>â€¢ float DamageMultiplier<br/>â€¢ TSubclassOf DamageType<br/>â€¢ FName SocketName"]
        end
        
        NOTIFY_TRACK -->|"references"| NOTIFY_CLASS
    end

    %% LAYER 0 NOTES
    subgraph LAYER0_NOTES["ğŸ“ LAYER 0 NOTES â”â” Animation Assets"]
        direction TB
        L0_QA["<b>â“ Common Questions</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Q: Notify vs NotifyState?<br/>A: Notify = instant frame event<br/>   NotifyState = duration window<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Q: Multiple notifies same frame?<br/>A: YES but order NOT guaranteed<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Q: Branching Point vs Notify?<br/>A: BranchingPoint = frame-perfect<br/>   Notify can slip 1-2 frames"]
        
        L0_CODE["<b>ğŸ“ UAnimNotify_OpenHitWindow.h</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>UCLASS<br/>class UAnimNotify_OpenHitWindow<br/>  : public UAnimNotify<br/>{<br/>  UPROPERTY EditAnywhere<br/>  float DamageMultiplier = 1.0f;<br/>  <br/>  virtual void Notify<br/>    USkeletalMeshComponent*,<br/>    UAnimSequenceBase*,<br/>    FAnimNotifyEventReference&<br/>  override;<br/>};"]
        
        L0_WARN["<b>âš ï¸ Gotchas</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>â€¢ Notify NOT replicated by default<br/>â€¢ Blended anims may fire 2x<br/>â€¢ Root motion can desync notify<br/>â€¢ Test with Queued notify track"]
        
        L0_QA ~~~ L0_CODE ~~~ L0_WARN
    end

    %% ============================================================
    %% LAYER 1: ANIMATION RUNTIME
    %% ============================================================
    subgraph LAYER1["ğŸ¬ LAYER 1: ANIMATION RUNTIME â”â” Engine Tick"]
        direction TB
        
        subgraph ANIM_INST["UAnimInstance"]
            direction TB
            ANIM_STATE["<b>Animation State Machine</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>â€¢ Processes montage playback<br/>â€¢ Detects notify triggers<br/>â€¢ Calls Notify virtual method"]
            
            MONTAGE_INST["<b>FAnimMontageInstance</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>float Position<br/>float PlayRate<br/>bool bPlaying<br/>int32 MontageInstanceID"]
            
            ANIM_STATE --> MONTAGE_INST
        end
        
        subgraph NOTIFY_EXEC["Notify Execution"]
            direction TB
            
            NOTIFY_PARAMS["<b>Parameters Received</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>USkeletalMeshComponent* MeshComp<br/>UAnimSequenceBase* Animation<br/>FAnimNotifyEventReference& Ref"]
            
            SKEL_MESH["<b>USkeletalMeshComponent</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Inheritance:<br/>USkeletalMeshComponent<br/> â†³ USkinnedMeshComponent<br/>  â†³ UMeshComponent<br/>   â†³ UPrimitiveComponent<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>GetOwner â†’ AActor*<br/>GetAnimInstance â†’ UAnimInstance*"]
            
            NOTIFY_PARAMS --> SKEL_MESH
        end
        
        MONTAGE_INST -->|"frame N reached"| NOTIFY_PARAMS
    end

    %% LAYER 1 NOTES
    subgraph LAYER1_NOTES["ğŸ“ LAYER 1 NOTES â”â” Runtime Execution"]
        direction TB
        L1_QA["<b>â“ Common Questions</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Q: Get owner Actor from notify?<br/>A: MeshCompâ†’GetOwner<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Q: Notify fires twice - why?<br/>A: Animation blend, looping,<br/>   or notify in SEQ + MONTAGE<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Q: Pass custom data to notify?<br/>A: Use UPROPERTY on notify class"]
        
        L1_CODE["<b>ğŸ“ AnimNotify_OpenHitWindow.cpp</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>void UAnimNotify_OpenHitWindow<br/>::Notify MeshComp, Anim, Ref<br/>{<br/>  Super::Notify ...;<br/>  if !MeshComp return;<br/>  <br/>  AActor* Owner = <br/>    MeshCompâ†’GetOwner;<br/>  if !Owner return;<br/>  <br/>  auto* HW = Ownerâ†’<br/>    FindComponentByClass<br/>      UHitWindowComponent;<br/>  if HW â†’ HWâ†’OpenWindow;<br/>}"]
        
        L1_LIFECYCLE["<b>ğŸ”„ UAnimInstance Lifecycle</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>NativeInitializeAnimation<br/>  â†“ called once on spawn<br/>NativeUpdateAnimation dt<br/>  â†“ called every frame<br/>BlueprintUpdateAnimation<br/>  â†“ BP event graph runs<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>âš ï¸ Thread Safety: UE5 anim<br/>runs on worker threads!<br/>Use ThreadSafe UPROPERTY"]
        
        L1_QA ~~~ L1_CODE ~~~ L1_LIFECYCLE
    end

    %% ============================================================
    %% DATA FLOW ANNOTATION
    %% ============================================================
    subgraph DATAFLOW1["ğŸ“¨ DATA FLOW: Notify â†’ Component"]
        DATA_NOTE["<b>What Crosses Boundary?</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>1. MeshCompâ†’GetOwner<br/>2. Cast to AHeroCharacter<br/>3. FindComponentByClass<br/>4. Invoke OpenWindow<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>DATA: None - pure control flow<br/>POINTER: Raw from engine âš ï¸"]
    end

    %% DATAFLOW NOTES
    subgraph DATAFLOW_NOTES["ğŸ“ DATAFLOW NOTES â”â” Architecture Patterns"]
        direction TB
        DF_PATTERN["<b>ğŸ—ï¸ Signal vs Data Delegates</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>SIGNAL signal-only:<br/>DECLARE_MULTICAST_DELEGATE<br/>  FOnWindowOpened<br/>Broadcast: OnWindowOpened.Broadcast<br/>Handler queries what it needs<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>DATA-CARRYING with payload:<br/>DECLARE_MULTICAST_DELEGATE_TwoParams<br/>  FOnDamageDealt, float, AActor*<br/>Broadcast passes data directly"]
        
        DF_ALT["<b>ğŸ”€ Interface Alternative</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>UINTERFACE MinimalAPI<br/>class UDamageable : UInterface {};<br/><br/>class IDamageable {<br/>  virtual void TakeDamage<br/>    float Amt, AActor* Src = 0;<br/>};<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Usage:<br/>if Ownerâ†’Implements UDamageable<br/>  IDamageable::Execute_TakeDamage<br/>    Owner, 35.f, this;"]
        
        DF_PATTERN ~~~ DF_ALT
    end

    %% ============================================================
    %% LAYER 2: TIMING GATEKEEPER
    %% ============================================================
    subgraph LAYER2["â±ï¸ LAYER 2: TIMING GATEKEEPER â”â” Signal Emitter"]
        direction TB
        
        subgraph RATIONALE["ğŸ’¡ DESIGN RATIONALE"]
            WHY_NAME["<b>Why UHitWindowComponent?</b><br/><b>Not USwordComponent?</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Single Responsibility:<br/>â€¢ Answers ONE question only<br/>â€¢ 'WHEN can damage occur?'<br/>â€¢ NOT what weapon or how much<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Decoupling:<br/>â€¢ Fists, swords, hammers, spells<br/>â€¢ ALL reuse same component"]
        end
        
        subgraph HITWINDOW["UHitWindowComponent"]
            direction TB
            
            HW_CLASS["<b>: UActorComponent</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"]
            
            DELEGATE_DECL["<b>Delegate Declaration</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>DECLARE_MULTICAST_DELEGATE<br/>  FOnAttackWindow<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Signature: void<br/>Parameters: NONE"]
            
            DELEGATE_INST["<b>Delegate Instance</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>FOnAttackWindow OnAttackWindow<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Internal: TArray FDelegate<br/> â””â”€ InvocationList"]
            
            OPEN_METHOD["<b>void OpenWindow</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>UFUNCTION BlueprintCallable<br/>OnAttackWindow.Broadcast<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Order is UNDEFINED âš ï¸"]
            
            HW_CLASS --> DELEGATE_DECL
            DELEGATE_DECL --> DELEGATE_INST
            DELEGATE_INST --> OPEN_METHOD
        end
    end

    %% LAYER 2 NOTES
    subgraph LAYER2_NOTES["ğŸ“ LAYER 2 NOTES â”â” Delegates Deep Dive"]
        direction TB
        L2_TYPES["<b>ğŸ“Š Delegate Type Matrix</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Type        â”‚BP?â”‚Speedâ”‚UFUNC?<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Static      â”‚ âŒ â”‚ âš¡  â”‚ âŒ<br/>StaticMulti â”‚ âŒ â”‚ âš¡  â”‚ âŒ<br/>Dynamic     â”‚ âœ… â”‚ ğŸ¢  â”‚ âœ…<br/>DynamicMultiâ”‚ âœ… â”‚ ğŸ¢  â”‚ âœ…<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>âš¡ = ~5-10ns  ğŸ¢ = ~50-100ns"]
        
        L2_HANDLE["<b>ğŸ”§ FDelegateHandle Cleanup</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>// Store handle for cleanup<br/>FDelegateHandle MyHandle;<br/><br/>void BeginPlay {<br/>  MyHandle = Delegate.AddUObject<br/>    this, &ThisClass::Handler;<br/>}<br/><br/>void EndPlay EEndPlayReason {<br/>  Delegate.Remove MyHandle;<br/>  // OR: Delegate.RemoveAll this;<br/>}"]
        
        L2_BIND["<b>ğŸ”— Binding Methods</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>AddUObject: UObject member func<br/>  Stores TWeakObjectPtr internally<br/>  Auto-removes if object destroyed<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>AddRaw: Non-UObject class<br/>  NO safety checks! Manual cleanup!<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>AddLambda: Inline function<br/>  Capture by value or weak ptr!<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>AddDynamic: Dynamic delegate only<br/>  Requires UFUNCTION on handler"]
        
        L2_TYPES ~~~ L2_HANDLE ~~~ L2_BIND
    end

    %% ============================================================
    %% LAYER 3: ACTOR COORDINATOR
    %% ============================================================
    subgraph LAYER3["ğŸ® LAYER 3: ACTOR COORDINATOR â”â” Command Center"]
        direction TB
        
        subgraph BEGINPLAY["BeginPlay Setup"]
            direction TB
            
            COMP_LOOKUP["<b>Component Discovery</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>HitWindow = FindComponentByClass<br/>  UHitWindowComponent<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Returns: raw ptr or nullptr<br/>MUST null-check âš ï¸"]
            
            BIND_DELEGATE["<b>Delegate Binding</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>HitWindowâ†’OnAttackWindow<br/>  .AddUObject<br/>    this,<br/>    &AHeroCharacter::HandleAttackWindow<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Stores TWeakObjectPtr + func ptr"]
            
            COMP_LOOKUP --> BIND_DELEGATE
        end
        
        subgraph HANDLE_ATTACK["HandleAttackWindow"]
            direction TB
            
            DAMAGE_DEF["<b>constexpr float Damage = 35.f</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Compile-time constant"]
            
            QUERY_VICTIMS["<b>QueryVictims</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Returns TArray AActor*<br/>Uses SweepMultiByChannel"]
            
            LOOP["<b>for AActor* Victim</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Range-based iteration"]
            
            DAMAGE_DEF --> QUERY_VICTIMS
            QUERY_VICTIMS --> LOOP
        end
    end

    %% LAYER 3 NOTES
    subgraph LAYER3_NOTES["ğŸ“ LAYER 3 NOTES â”â” Character & Networking"]
        direction TB
        L3_NETWORK["<b>ğŸŒ MULTIPLAYER CRITICAL</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>void HandleAttackWindow {<br/>  // âš ï¸ ONLY SERVER calculates!<br/>  if !HasAuthority return;<br/>  <br/>  for AActor* Victim : QueryVictims<br/>  {<br/>    // Damage on server only<br/>    // Health replicates to clients<br/>    ApplyDamage Victim, 35.f;<br/>  }<br/>}<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Client traces are COSMETIC only"]
        
        L3_LIFECYCLE["<b>ğŸ”„ Init Order</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Constructor<br/>  â†“ components created here<br/>PostInitializeComponents<br/>  â†“ components ready, bind here!<br/>BeginPlay<br/>  â†“ world ready, game started<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>ğŸ’¡ PostInitializeComponents<br/>   is safer than BeginPlay<br/>   for component dependencies"]
        
        L3_ENSURE["<b>âœ… Validation Patterns</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>// Dev assertion - crash in editor<br/>ensureMsgf HitWindow,<br/>  TEXT Requires HitWindowComponent!;<br/><br/>// Always crash if fails<br/>check HitWindow != nullptr;<br/><br/>// Log and continue<br/>if !HitWindow {<br/>  UE_LOG LogCombat, Error,<br/>    TEXT No HitWindow!;<br/>  return;<br/>}"]
        
        L3_NETWORK ~~~ L3_LIFECYCLE ~~~ L3_ENSURE
    end

    %% ============================================================
    %% LAYER 4: PHYSICS QUERY
    %% ============================================================
    subgraph LAYER4["ğŸŒ LAYER 4: PHYSICS QUERY â”â” World Traces"]
        direction TB
        
        subgraph TRACE_CONFIG["Trace Configuration"]
            COLL_PARAMS["<b>FCollisionQueryParams</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>TraceTag: FName debug<br/>bTraceComplex: per-poly<br/>bReturnPhysicalMaterial: true<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>AddIgnoredActor: self"]
            
            COLL_SHAPE["<b>FCollisionShape</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>MakeSphere: radius<br/>MakeCapsule: r, hh<br/>MakeBox: half extents"]
            
            COLL_CHANNEL["<b>ECollisionChannel</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>ECC_Pawn: default<br/>ECC_GameTraceChannel1:<br/>  Custom 'Attack' channel"]
            
            COLL_PARAMS --> COLL_SHAPE --> COLL_CHANNEL
        end
        
        subgraph TRACE_EXEC["Trace Execution"]
            SWEEP_CALL["<b>GetWorldâ†’SweepMultiByChannel</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>TArray FHitResult& OutHits<br/>FVector Start, End<br/>FQuat Rotation<br/>ECollisionChannel Channel<br/>FCollisionShape Shape<br/>FCollisionQueryParams Params<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Returns: bool bHitSomething"]
        end
        
        subgraph HITRESULT["FHitResult â”â” Key Members"]
            direction TB
            
            HR_FLAGS["<b>â”â” Flags â”â”</b><br/>bBlockingHit: bool<br/>bStartPenetrating: bool"]
            
            HR_VEC["<b>â”â” Spatial â”â”</b><br/>ImpactPoint: FVector surface<br/>ImpactNormal: FVector dir<br/>Distance: float from start"]
            
            HR_REF["<b>â”â” References â”â”</b><br/>GetActor â†’ AActor*<br/>GetComponent â†’ UPrimComp*<br/>PhysMaterial â†’ surface type<br/>BoneName â†’ skeletal bone"]
            
            HR_FLAGS ~~~ HR_VEC ~~~ HR_REF
        end
        
        TRACE_EXEC --> HITRESULT
    end

    %% LAYER 4 NOTES
    subgraph LAYER4_NOTES["ğŸ“ LAYER 4 NOTES â”â” Traces & Debug"]
        direction TB
        L4_TYPES["<b>ğŸ“Š Trace Type Decision</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>LINE TRACE â•â•â•â•â•â•â•â•â•â•â•â•><br/>â€¢ Infinitely thin, fast<br/>â€¢ Bullets, lasers, hitscan<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>SPHERE SWEEP  â—â”â”â”â”â”â”â—<br/>â€¢ Radius gives forgiveness<br/>â€¢ Melee attacks, pickups<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>CAPSULE SWEEP â•­â”€â•®â”â”â”â•­â”€â•®<br/>â€¢ Character-shaped<br/>â€¢ Large weapons, cleaves"]
        
        L4_DEBUG["<b>ğŸ› Debug Visualization</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>#if !UE_BUILD_SHIPPING<br/>DrawDebugSphere GetWorld,<br/>  Start, Radius, 12,<br/>  bHit ? FColor::Green<br/>       : FColor::Red,<br/>  false, 0.5f;<br/><br/>DrawDebugLine GetWorld,<br/>  Start, End,<br/>  FColor::Yellow,<br/>  false, 0.5f, 0, 2.f;<br/>#endif<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Console: show collision"]
        
        L4_ASYNC["<b>âš¡ Async Traces Performance</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>// For heavy queries 100+<br/>FTraceHandle Handle =<br/>  GetWorldâ†’AsyncSweepByChannel<br/>    EAsyncTraceType::Multi,<br/>    Start, End,<br/>    ECC_Attack,<br/>    Shape,<br/>    Params,<br/>    &MyTraceDelegate;<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Results arrive next frame<br/>via FTraceDelegate callback"]
        
        L4_TYPES ~~~ L4_DEBUG ~~~ L4_ASYNC
    end

    %% ============================================================
    %% LAYER 5: STATE MANAGEMENT
    %% ============================================================
    subgraph LAYER5["â¤ï¸ LAYER 5: STATE MANAGEMENT â”â” Health Component"]
        direction TB
        
        subgraph HEALTH_PROPS["State Properties"]
            PROPS["<b>UPROPERTY EditAnywhere</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>float Health<br/>float MaxHealth = 100.f<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>UPROPERTY enables:<br/>â€¢ GC tracking<br/>â€¢ Serialization<br/>â€¢ Editor exposure"]
        end
        
        subgraph DUAL_DELEGATES["Dual Delegate System"]
            direction TB
            
            NATIVE_DECL["<b>â”â” C++ Systems â”â”</b><br/>DECLARE_MULTICAST_DELEGATE_TwoParams<br/>  FOnDamagedNative,<br/>  float Amount,<br/>  AActor* Causer<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Faster, C++ only"]
            
            FX_DECL["<b>â”â” Blueprint â”â”</b><br/>DECLARE_DYNAMIC_MULTICAST_DELEGATE<br/>  _TwoParams<br/>  FOnDamagedFX,<br/>  float, Amount,<br/>  AActor*, Causer<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Slower, BP-visible"]
            
            NATIVE_DECL ~~~ FX_DECL
        end
        
        subgraph APPLY_DMG["ApplyDamage Method"]
            direction TB
            
            CLAMP["<b>State Mutation</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Health = FMath::Clamp<br/>  Health - Amount,<br/>  0.f, MaxHealth"]
            
            BC_NATIVE["<b>OnDamagedNative.Broadcast</b>"]
            
            BC_FX["<b>OnDamagedFX.Broadcast</b>"]
            
            DEATH["<b>if Health <= 0.f</b><br/>  OnDeath.Broadcast"]
            
            CLAMP --> BC_NATIVE --> BC_FX --> DEATH
        end
    end

    %% LAYER 5 NOTES
    subgraph LAYER5_NOTES["ğŸ“ LAYER 5 NOTES â”â” Damage System"]
        direction TB
        L5_DAMAGETYPE["<b>ğŸ¯ UDamageType Integration</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>// Custom damage types<br/>UCLASS<br/>class UFireDamageType<br/>  : public UDamageType {};<br/><br/>// Apply with type<br/>UGameplayStatics::ApplyDamage<br/>  Victim, 35.f,<br/>  InstigatorController,<br/>  DamageCauser,<br/>  UFireDamageType::StaticClass;<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Receiver checks type for<br/>resistance/immunity"]
        
        L5_PIPELINE["<b>ğŸ”„ Damage Pipeline</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>RAW DAMAGE 35.f<br/>      â”‚<br/>      â–¼<br/>â”Œâ”€ Pre-Modifier â”€â”<br/>â”‚ Armor: 0.8x    â”‚<br/>â”‚ Fire Resist    â”‚<br/>â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜<br/>        â”‚ 28.f<br/>        â–¼<br/>â”Œâ”€ Health Comp â”€â”<br/>â”‚ Clamp/Apply   â”‚<br/>â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜<br/>        â”‚<br/>        â–¼<br/>Broadcast to listeners"]
        
        L5_REPLICATE["<b>ğŸŒ Network Replication</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>UPROPERTY Replicated<br/>float Health;<br/><br/>void GetLifetimeReplicatedProps<br/>  TArray FLifetimeProperty& Out<br/>{<br/>  DOREPLIFETIME ThisClass, Health;<br/>}<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Health syncs serverâ†’clients<br/>Damage calc ONLY on server"]
        
        L5_DAMAGETYPE ~~~ L5_PIPELINE ~~~ L5_REPLICATE
    end

    %% ============================================================
    %% LAYER 6: NATIVE RESPONDERS
    %% ============================================================
    subgraph LAYER6["âš™ï¸ LAYER 6: NATIVE RESPONDERS â”â” C++ Systems"]
        direction TB
        
        COMBO["<b>UComboMeterComponent</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Tracks consecutive hits<br/>Resets on timer expiry<br/>Multiplies damage/score"]
        
        AGGRO["<b>UAIAggroManager</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Updates threat tables<br/>Influences AI targeting"]
        
        STATS["<b>UAnalyticsSubsystem</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Records damage dealt<br/>Tracks damage sources"]
        
        ARMOR["<b>UArmorComponent</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Pre-processes damage<br/>Applies resistances"]
        
        NATIVE_BIND["<b>Binding Pattern</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>HealthCompâ†’OnDamagedNative<br/>  .AddUObject this,<br/>  &UComboMeter::OnDamageDealt"]
    end

    %% LAYER 6 NOTES
    subgraph LAYER6_NOTES["ğŸ“ LAYER 6 NOTES â”â” C++ Architecture"]
        direction TB
        L6_SUBSYSTEM["<b>ğŸ—ï¸ Subsystem Pattern Modern</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>// Better than singleton managers<br/>UCLASS<br/>class UCombatSubsystem<br/>  : public UGameInstanceSubsystem<br/>{<br/>  // Auto-created with GameInstance<br/>  // Survives level transitions<br/>  // Clean lifecycle management<br/>};<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>// Access anywhere:<br/>auto* Combat = GetGameInstance<br/>  â†’GetSubsystem UCombatSubsystem;"]
        
        L6_ORDER["<b>âš ï¸ Execution Order Problem</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Multicast delegate order<br/>is NOT guaranteed!<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>If Armor must run BEFORE Combo:<br/>1. Use ordered container<br/>2. Single orchestrator component<br/>3. Chain delegates manually<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>// Orchestrator pattern:<br/>void OnDamage float Amt {<br/>  Amt = Armorâ†’Process Amt;<br/>  Comboâ†’Record Amt;<br/>  // Explicit order<br/>}"]
        
        L6_GAS["<b>ğŸ†š GAS Comparison</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>This Architecture:<br/>â€¢ Simple, direct, readable<br/>â€¢ Good for action games<br/>â€¢ You own the code<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>GameplayAbilitySystem:<br/>â€¢ More complex, more features<br/>â€¢ RPG/MOBA style games<br/>â€¢ Built-in prediction/replication<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Consider GAS if you need:<br/>â€¢ Cooldowns, costs, tags<br/>â€¢ Complex ability interactions"]
        
        L6_SUBSYSTEM ~~~ L6_ORDER ~~~ L6_GAS
    end

    %% ============================================================
    %% LAYER 7: COSMETIC RESPONDERS
    %% ============================================================
    subgraph LAYER7["ğŸ¨ LAYER 7: COSMETIC RESPONDERS â”â” BP/Art Layer"]
        direction TB
        
        VFX["<b>BP_BloodVFXSpawner</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>SpawnSystemAtLocation<br/>Uses ImpactPoint<br/>Scales with damage"]
        
        SFX["<b>BP_HitSoundPlayer</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Plays sound at location<br/>Based on PhysMaterial"]
        
        SHAKE["<b>BP_CameraShakeManager</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Player cam shake<br/>Scales with damage"]
        
        DMGNUM["<b>WBP_DamageNumbers</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>UI widget spawn<br/>World-space position"]
        
        HITREACT["<b>ABP_HitReaction</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Hit react montage<br/>Direction-based select"]
        
        BP_BIND["<b>Blueprint Binding</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>UPROPERTY BlueprintAssignable<br/>enables 'Assign' node"]
    end

    %% LAYER 7 NOTES
    subgraph LAYER7_NOTES["ğŸ“ LAYER 7 NOTES â”â” FX & Networking"]
        direction TB
        L7_MULTICAST["<b>ğŸŒ Multicast RPC for FX</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>// FX runs on ALL clients<br/>UFUNCTION NetMulticast, Unreliable<br/>void Multicast_PlayHitFX<br/>  FVector Loc, FRotator Rot;<br/><br/>void Multicast_PlayHitFX_Impl<br/>  FVector Loc, FRotator Rot<br/>{<br/>  // Runs everywhere<br/>  UNiagaraFunctionLibrary::<br/>    SpawnSystemAtLocation ...;<br/>  UGameplayStatics::<br/>    PlaySoundAtLocation ...;<br/>}<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Unreliable = OK for cosmetics"]
        
        L7_NIAGARA["<b>âœ¨ Niagara UE5 Pattern</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>// Cascade is deprecated!<br/>UNiagaraFunctionLibrary::<br/>  SpawnSystemAtLocation<br/>    GetWorld,<br/>    BloodSplatterSystem,<br/>    ImpactPoint,<br/>    ImpactNormal.Rotation,<br/>    FVector Scale,<br/>    true,  // bAutoDestroy<br/>    true   // bAutoActivate<br/>  ;"]
        
        L7_CONCURRENCY["<b>ğŸ”Š Sound Concurrency</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>// Prevent sound stacking<br/>USoundConcurrency* Concurrency;<br/><br/>// In asset or code:<br/>MaxCount = 3;<br/>ResolutionRule = StopFarthestThenOldest;<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Multiple hits won't create<br/>10+ overlapping sounds"]
        
        L7_MULTICAST ~~~ L7_NIAGARA ~~~ L7_CONCURRENCY
    end

    %% ============================================================
    %% MEMORY REFERENCE
    %% ============================================================
    subgraph MEMORY["ğŸ§  MEMORY MANAGEMENT REFERENCE"]
        direction TB
        
        PTR_TYPES["<b>Pointer Types</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>UPROPERTY T*: GC-tracked âœ“<br/>TWeakObjectPtr: safe weak âœ“<br/>Raw T*: NOT GC-aware âš ï¸<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>if ptr: null check<br/>IsValid ptr: null + pending kill<br/>WeakPtr.IsValid: safe check"]
        
        DEL_SAFETY["<b>Delegate Safety</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>AddUObject stores weak ptr<br/>Auto-removes on destroy<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>NEVER bind raw ptr âš ï¸<br/>NEVER capture raw in lambda âš ï¸"]
    end

    %% MEMORY NOTES
    subgraph MEMORY_NOTES["ğŸ“ MEMORY NOTES â”â” Pointer Deep Dive"]
        direction TB
        MEM_LAMBDA["<b>ğŸ”’ Safe Lambda Capture</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>// âŒ DANGEROUS - raw capture<br/>auto Bad = [this] {<br/>  thisâ†’DoThing; // may crash!<br/>};<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>// âœ… SAFE - weak capture<br/>TWeakObjectPtr WeakThis this;<br/>auto Good = [WeakThis] {<br/>  if WeakThis.IsValid<br/>    WeakThisâ†’DoThing;<br/>};"]
        
        MEM_DEBUG["<b>ğŸ› Debug Commands</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>obj refs ClassName<br/>  Shows reference chains<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>obj list Class=ClassName<br/>  Lists all instances<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>gc.CollectGarbageEveryFrame 1<br/>  Force GC for testing"]
        
        MEM_LAMBDA ~~~ MEM_DEBUG
    end

    %% ============================================================
    %% CROSS-CUTTING: DEBUGGING
    %% ============================================================
    subgraph DEBUG_SECTION["ğŸ› DEBUGGING REFERENCE"]
        direction TB
        
        DEBUG_CONSOLE["<b>Console Commands</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>show collision<br/>stat game<br/>stat fps<br/>slomo 0.1<br/>p.VisualizeMovement 1"]
        
        DEBUG_LOG["<b>Logging</b><br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>DECLARE_LOG_CATEGORY_EXTERN<br/>  LogCombat, Log, All<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>UE_LOG LogCombat, Warning,<br/>  TEXT Hit %s, *Name"]
    end

    %% ============================================================
    %% CONNECTIONS - Main Flow
    %% ============================================================
    LAYER0 ==>|"Montage plays"| LAYER1
    LAYER1 ==>|"Notify called"| DATAFLOW1
    DATAFLOW1 ==>|"OpenWindow"| LAYER2
    LAYER2 ==>|"Broadcast signal"| LAYER3
    LAYER3 ==>|"SweepMulti"| LAYER4
    LAYER4 ==>|"FHitResult array"| LAYER3
    LAYER3 ==>|"ApplyDamage"| LAYER5
    LAYER5 ==>|"OnDamagedNative"| LAYER6
    LAYER5 ==>|"OnDamagedFX"| LAYER7

    %% CONNECTIONS - Notes (dotted)
    LAYER0 -.->|"ğŸ“"| LAYER0_NOTES
    LAYER1 -.->|"ğŸ“"| LAYER1_NOTES
    DATAFLOW1 -.->|"ğŸ“"| DATAFLOW_NOTES
    LAYER2 -.->|"ğŸ“"| LAYER2_NOTES
    LAYER3 -.->|"ğŸ“"| LAYER3_NOTES
    LAYER4 -.->|"ğŸ“"| LAYER4_NOTES
    LAYER5 -.->|"ğŸ“"| LAYER5_NOTES
    LAYER6 -.->|"ğŸ“"| LAYER6_NOTES
    LAYER7 -.->|"ğŸ“"| LAYER7_NOTES
    MEMORY -.->|"ğŸ“"| MEMORY_NOTES

    %% ============================================================
    %% STYLES
    %% ============================================================
    classDef layer0 fill:#2d1b4e,stroke:#9b59b6,stroke-width:2px,color:#fff
    classDef layer1 fill:#1a3a5c,stroke:#3498db,stroke-width:2px,color:#fff
    classDef layer2 fill:#4a3000,stroke:#f39c12,stroke-width:3px,color:#fff
    classDef layer3 fill:#1e4d2b,stroke:#27ae60,stroke-width:2px,color:#fff
    classDef layer4 fill:#3d1f1f,stroke:#e74c3c,stroke-width:2px,color:#fff
    classDef layer5 fill:#4a1942,stroke:#e91e8b,stroke-width:2px,color:#fff
    classDef layer6 fill:#0d3d4a,stroke:#00bcd4,stroke-width:3px,color:#fff
    classDef layer7 fill:#2e4a1e,stroke:#8bc34a,stroke-width:3px,color:#fff
    classDef note fill:#3d3d00,stroke:#ffd93d,stroke-width:2px,color:#ffd93d
    classDef dataflow fill:#1a1a2e,stroke:#61dafb,stroke-width:2px,color:#61dafb
    classDef memory fill:#2a1a3a,stroke:#bb86fc,stroke-width:2px,color:#bb86fc
    classDef notes fill:#1a1a1a,stroke:#ff9800,stroke-width:2px,stroke-dasharray:5 5,color:#ff9800
    classDef debug fill:#2a2a00,stroke:#ffd93d,stroke-width:2px,color:#ffd93d

    class LAYER0 layer0
    class LAYER1 layer1
    class LAYER2 layer2
    class LAYER3 layer3
    class LAYER4 layer4
    class LAYER5 layer5
    class LAYER6 layer6
    class LAYER7 layer7
    class DATAFLOW1,RATIONALE note
    class MEMORY memory
    class LAYER0_NOTES,LAYER1_NOTES,LAYER2_NOTES,LAYER3_NOTES,LAYER4_NOTES,LAYER5_NOTES,LAYER6_NOTES,LAYER7_NOTES,DATAFLOW_NOTES,MEMORY_NOTES notes
    class DEBUG_SECTION debug
        </div>
        </div>
    </div>
    
    <!-- ============================================================ -->
    <!-- QUICK CODE REFERENCE - EXPANDED -->
    <!-- ============================================================ -->
    <div class="quick-ref">
        <h2>ğŸ“š Quick Code Reference (10 Cards)</h2>
        
        <div class="section-divider">â”â”â” Core Patterns â”â”â”</div>
        
        <div class="ref-grid">
            <div class="ref-card delegate">
                <h3>1. Delegate Declarations</h3>
                <div class="file-path">ğŸ“HitWindowComponent.h</div>
                <pre><code>// Signal-only (no payload)
DECLARE_MULTICAST_DELEGATE(FOnAttackWindow); <a class="puzzle-tag" href="/lego/dynamic-multicast-delegate" title="Learn: Dynamic Multicast Delegate">Delegate</a>

// With parameters (C++ only)
DECLARE_MULTICAST_DELEGATE_TwoParams(
    FOnDamagedNative,
    float, Amount,
    AActor*, Causer
);

// Blueprint-visible
DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(
    FOnDamagedFX,
    float, Amount,
    AActor*, Causer
);</code></pre>
            </div>
            
            <div class="ref-card pattern">
                <h3>2. Binding with Cleanup</h3>
                <div class="file-path">ğŸ“ HeroCharacter.cpp</div>
                <pre><code>// Store handle for cleanup
FDelegateHandle WindowHandle;

void AHeroCharacter::BeginPlay() {
    Super::BeginPlay();
    
    HitWindow = FindComponentByClass <a class="puzzle-tag" href="/lego/findcomponentbyclass" title="Learn: FindComponentByClass">FindComp</a>
        &lt;UHitWindowComponent&gt;();
        
    if (HitWindow) {
        WindowHandle = HitWindow->
            OnAttackWindow.AddUObject(
                this,
                &AHeroCharacter::HandleWindow
            );
    }
}

void AHeroCharacter::EndPlay(
    const EEndPlayReason::Type Reason) {
    if (HitWindow) {
        HitWindow->OnAttackWindow
            .Remove(WindowHandle);
    }
    Super::EndPlay(Reason);
}</code></pre>
            </div>
            
            <div class="ref-card notify">
                <h3>3. AnimNotify Implementation</h3>
                <div class="file-path">ğŸ“ AnimNotify_OpenHitWindow.h/.cpp</div>
                <pre><code>// Header
UCLASS()
class UAnimNotify_OpenHitWindow 
    : public UAnimNotify
{
    GENERATED_BODY()
public:
    UPROPERTY(EditAnywhere, Category="Combat")
    float DamageMultiplier = 1.0f;
    
    virtual void Notify(
        USkeletalMeshComponent* MeshComp,
        UAnimSequenceBase* Animation,
        const FAnimNotifyEventReference& Ref
    ) override;
};

// Implementation
void UAnimNotify_OpenHitWindow::Notify(...) {
    Super::Notify(MeshComp, Animation, Ref);
    if (!MeshComp) return;
    
    AActor* Owner = MeshComp->GetOwner();
    if (!Owner) return;
    
    if (auto* HW = Owner->FindComponentByClass
            &lt;UHitWindowComponent&gt;()) {
        HW->OpenWindow();
    }
}</code></pre>
            </div>
            
            <div class="ref-card trace">
                <h3>4. Sweep Trace Query</h3>
                <div class="file-path">ğŸ“ HeroCharacter.cpp - QueryVictims()</div>
                <pre><code>TArray&lt;AActor*&gt; AHeroCharacter::QueryVictims() {
    TArray&lt;AActor*&gt; Victims;
    TArray&lt;FHitResult&gt; OutHits;
    
    FCollisionQueryParams Params; <a class="puzzle-tag" href="/lego/fcollisionqueryparams" title="Learn: FCollisionQueryParams">Params</a>
    Params.AddIgnoredActor(this);
    Params.bTraceComplex = false;
    Params.bReturnPhysicalMaterial = true;
    
    FCollisionShape Shape = 
        FCollisionShape::MakeSphere(AttackRadius);
    
    FVector Start = GetActorLocation() + 
        GetActorForwardVector() * 50.f;
    FVector End = Start + 
        GetActorForwardVector() * 200.f;
    
    bool bHit = GetWorld()->SweepMultiByChannel( <a class="puzzle-tag" href="/lego/sweepsinglebychannel" title="Learn: SweepSingleByChannel">Sweep</a>
        OutHits, Start, End, FQuat::Identity,
        ECC_GameTraceChannel1, // Attack channel
        Shape, Params
    );
    
    if (bHit) {
        for (const FHitResult& Hit : OutHits) {
            if (AActor* A = Hit.GetActor())
                Victims.AddUnique(A);
        }
    }
    return Victims;
}</code></pre>
            </div>
        </div>
        
        <div class="section-divider">â”â”â” Health & Damage â”â”â”</div>
        
        <div class="ref-grid">
            <div class="ref-card health">
                <h3>5. Health Component</h3>
                <div class="file-path">ğŸ“ HealthComponent.h/.cpp</div>
                <pre><code>UCLASS(ClassGroup=(Combat), 
    meta=(BlueprintSpawnableComponent))
class UHealthComponent : public UActorComponent
{
    GENERATED_BODY()
public:
    // Native delegate (C++ only, fast)
    DECLARE_MULTICAST_DELEGATE_TwoParams(
        FOnDamagedNative, float, AActor*);
    FOnDamagedNative OnDamagedNative;
    
    // Dynamic delegate (BP visible)
    DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(
        FOnDamagedFX, float, Amount, 
        AActor*, Causer);
    UPROPERTY(BlueprintAssignable)
    FOnDamagedFX OnDamagedFX;
    
    UPROPERTY(BlueprintAssignable)
    FOnDeath OnDeath;
    
    void ApplyDamage(float Amt, AActor* Src) {
        if (!bCanTakeDamage || Health <= 0.f) 
            return;
        
        Health = FMath::Clamp( <a class="puzzle-tag" href="/lego/fmathclamp" title="Learn: FMath::Clamp">Clamp</a>
            Health - Amt, 0.f, MaxHealth);
        
        OnDamagedNative.Broadcast(Amt, Src);
        OnDamagedFX.Broadcast(Amt, Src);
        
        if (Health <= 0.f)
            OnDeath.Broadcast();
    }
};</code></pre>
            </div>
            
            <div class="ref-card damage">
                <h3>6. DamageType System</h3>
                <div class="file-path">ğŸ“ MyDamageTypes.h</div>
                <pre><code>// Custom damage types
UCLASS()
class UFireDamageType : public UDamageType {
    GENERATED_BODY()
};

UCLASS()
class UIceDamageType : public UDamageType {
    GENERATED_BODY()
};

// Applying typed damage
void DealDamage(AActor* Victim) {
    UGameplayStatics::ApplyDamage(
        Victim,
        35.f,
        GetController(),
        this,  // Damage causer
        UFireDamageType::StaticClass()
    );
}

// Receiving & checking type
void OnTakeAnyDamage(AActor* Damaged, 
    float Damage, const UDamageType* Type,
    AController* Instigator, AActor* Causer) 
{
    if (Type->IsA&lt;UFireDamageType&gt;()) {
        Damage *= FireResistance; // 0.5 = 50% resist
    }
    Health -= Damage;
}</code></pre>
            </div>
        </div>
        
        <div class="section-divider">â”â”â” Networking & Debug â”â”â”</div>
        
        <div class="ref-grid">
            <div class="ref-card network">
                <h3>7. Server Authority Pattern</h3>
                <div class="file-path">ğŸ“ HeroCharacter.cpp - Multiplayer</div>
                <pre><code>void AHeroCharacter::HandleAttackWindow() {
    // âš ï¸ CRITICAL: Only server processes damage
    if (!HasAuthority()) return; <a class="puzzle-tag" href="/lego/hasauthority-networking" title="Learn: HasAuthority() (Networking)">Network</a>
    
    for (AActor* Victim : QueryVictims()) {
        if (auto* HC = Victim->FindComponentByClass
                &lt;UHealthComponent&gt;()) {
            // Server applies damage
            // Health replicates to clients
            HC->ApplyDamage(35.f, this);
            
            // Trigger FX on all clients
            Multicast_PlayHitFX(
                CachedHit.ImpactPoint,
                CachedHit.ImpactNormal.Rotation()
            );
        }
    }
}

// Runs on ALL clients including server
UFUNCTION(NetMulticast, Unreliable)
void Multicast_PlayHitFX(FVector Loc, FRotator Rot);

void AHeroCharacter::Multicast_PlayHitFX_Impl(
    FVector Loc, FRotator Rot) {
    UNiagaraFunctionLibrary::SpawnSystemAtLocation(
        GetWorld(), BloodFX, Loc, Rot);
    UGameplayStatics::PlaySoundAtLocation(
        this, HitSound, Loc);
}</code></pre>
            </div>
            
            <div class="ref-card network">
                <h3>8. Health Replication</h3>
                <div class="file-path">ğŸ“ HealthComponent.h/.cpp</div>
                <pre><code>// Header - mark for replication
UPROPERTY(ReplicatedUsing=OnRep_Health)
float Health = 100.f;

UFUNCTION()
void OnRep_Health();

// Source
void UHealthComponent::GetLifetimeReplicatedProps(
    TArray&lt;FLifetimeProperty&gt;& OutProps) const 
{
    Super::GetLifetimeReplicatedProps(OutProps);
    
    DOREPLIFETIME(UHealthComponent, Health);
    // Or with condition:
    // DOREPLIFETIME_CONDITION(
    //     UHealthComponent, Health,
    //     COND_OwnerOnly);
}

void UHealthComponent::OnRep_Health() {
    // Called on clients when Health replicates
    OnHealthChanged.Broadcast(Health);
    
    if (Health <= 0.f) {
        // Client-side death effects
        PlayDeathAnimation();
    }
}</code></pre>
            </div>
            
            <div class="ref-card debug">
                <h3>9. Debug Visualization</h3>
                <div class="file-path">ğŸ“ HeroCharacter.cpp - Debug Helpers</div>
                <pre><code>#include "DrawDebugHelpers.h"

void AHeroCharacter::DebugDrawAttack() {
#if !UE_BUILD_SHIPPING
    FVector Start = GetActorLocation();
    FVector End = Start + 
        GetActorForwardVector() * 200.f;
    
    // Draw sweep sphere
    DrawDebugSphere( <a class="puzzle-tag" href="/lego/drawdebugline" title="Learn: DrawDebugLine">Debug</a>
        GetWorld(), Start, AttackRadius,
        12, FColor::Yellow, false, 0.5f);
    
    // Draw attack direction
    DrawDebugDirectionalArrow(
        GetWorld(), Start, End, 50.f,
        FColor::Red, false, 0.5f, 0, 3.f);
    
    // Draw hit points
    for (const FHitResult& Hit : CachedHits) {
        DrawDebugPoint(
            GetWorld(), Hit.ImpactPoint,
            10.f, FColor::Green, false, 0.5f);
        DrawDebugLine(
            GetWorld(), Hit.ImpactPoint,
            Hit.ImpactPoint + Hit.ImpactNormal * 50.f,
            FColor::Blue, false, 0.5f);
    }
#endif
}

// Console commands reference:
// show collision - visualize collision
// p.VisualizeMovement 1 - movement debug
// stat game - performance stats
// slomo 0.1 - slow motion for debugging</code></pre>
            </div>
            
            <div class="ref-card memory">
                <h3>10. Safe Pointer Patterns</h3>
                <div class="file-path">ğŸ“ Various - Memory Safety</div>
                <pre><code>// âŒ BAD - crashes if Target destroyed
Target->TakeDamage(50.f);

// âœ… GOOD - null check
if (Target) {
    Target->TakeDamage(50.f);
}

// âœ… BETTER - checks PendingKill too
if (IsValid(Target)) {
    Target->TakeDamage(50.f);
}

// âœ… Weak pointer for caching
TWeakObjectPtr&lt;AActor&gt; WeakTarget; <a class="puzzle-tag" href="/lego/tweakobjectptr" title="Learn: TWeakObjectPtr">WeakPtr</a>
if (WeakTarget.IsValid()) {
    WeakTarget->TakeDamage(50.f);
}

// âœ… Safe lambda capture
TWeakObjectPtr&lt;AMyActor&gt; WeakThis(this);
auto SafeLambda = [WeakThis]() {
    if (WeakThis.IsValid()) {
        WeakThis->DoSomething();
    }
};

// Timer with weak capture
FTimerDelegate TimerDel;
TimerDel.BindWeakLambda(this, [this]() { <a class="puzzle-tag" href="/lego/ftimerhandle-settimer" title="Learn: FTimerHandle & SetTimer">Timer</a>
    // Safe - timer auto-cancels if 'this' dies
    DoDelayedThing();
});
GetWorldTimerManager().SetTimer(
    TimerHandle, TimerDel, 1.f, false);</code></pre>
            </div>
        </div>
    </div>

    <!-- ============================================================ -->
    <!-- CODE FLOW IN ORDER - Complete Walkthrough -->
    <!-- ============================================================ -->
    <div class="quick-ref" style="margin-top: 40px;">
        <h2>ğŸ”„ Code Flow in Order - Complete Walkthrough</h2>
        <p style="color: #888; margin-bottom: 30px; font-size: 0.95rem;">
            Follow this step-by-step guide to see how all pieces connect from animation to damage.
            Each step maps to layers in the diagram above.
        </p>

        <div class="ref-grid" style="grid-template-columns: 1fr;">

            <!-- Step 0: Setup Phase -->
            <div class="ref-card pattern" style="border-left-width: 6px;">
                <h3>ğŸ“¦ Step 0: Setup Phase (BeginPlay) - LAYER 3</h3>
                <div class="file-path">ğŸ“ HeroCharacter.h/.cpp</div>
                <pre><code>// HeroCharacter.h
UCLASS()
class AHeroCharacter : public ACharacter
{
    GENERATED_BODY()

protected:
    virtual void BeginPlay() override;
    virtual void EndPlay(const EEndPlayReason::Type Reason) override;

    // Handler called by delegate
    void HandleAttackWindow();

    // Query for victims in attack range
    TArray&lt;AActor*&gt; QueryVictims();

private:
    UPROPERTY()
    UHitWindowComponent* HitWindow;

    FDelegateHandle WindowHandle;

    float AttackRadius = 80.f;
};

// HeroCharacter.cpp
void AHeroCharacter::BeginPlay() <a class="puzzle-tag" href="/lego/beginplay" title="Learn: BeginPlay()">Begin</a>
{
    Super::BeginPlay();

    // Find the HitWindowComponent on this actor
    HitWindow = FindComponentByClass&lt;UHitWindowComponent&gt;(); <a class="puzzle-tag" href="/lego/findcomponentbyclass" title="Learn: FindComponentByClass">FindComp</a>

    if (HitWindow)
    {
        // Subscribe to the delegate
        // "When OnAttackWindow broadcasts, call my HandleAttackWindow()"
        WindowHandle = HitWindow->OnAttackWindow.AddUObject(
            this,
            &AHeroCharacter::HandleAttackWindow
        );
    }
    else
    {
        UE_LOG(LogTemp, Error,
            TEXT("HeroCharacter requires UHitWindowComponent!"));
    }
}

void AHeroCharacter::EndPlay(const EEndPlayReason::Type Reason)
{
    // Clean up delegate binding
    if (HitWindow && WindowHandle.IsValid())
    {
        HitWindow->OnAttackWindow.Remove(WindowHandle);
    }

    Super::EndPlay(Reason);
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ğŸ’¡ What Happened?
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 1. Character finds HitWindowComponent on itself
// 2. Character subscribes to OnAttackWindow delegate
// 3. Now waiting for animation to trigger the window...</code></pre>
            </div>

            <!-- Step 1: Asset Domain -->
            <div class="ref-card notify" style="border-left-width: 6px;">
                <h3>ğŸ“ Step 1: Asset Domain - LAYER 0</h3>
                <div class="file-path">ğŸ“ Content/Animations/AM_SwordSlash.uasset (Editor)</div>
                <pre><code>// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// IN THE EDITOR - UAnimMontage Setup
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

UAnimMontage: AM_SwordSlash
â”œâ”€ Animation Sequence: Sword_Slash_Anim
â”œâ”€ Notify Track:
â”‚   â””â”€ [Frame 15] AnimNotify_OpenHitWindow
â”‚       â”œâ”€ DamageMultiplier: 1.5
â”‚       â”œâ”€ DamageType: USlashDamageType
â”‚       â””â”€ SocketName: "WeaponTip"
â””â”€ Sections: Default, Recovery

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// What's Happening?
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// Artist places notify at exact frame sword should hit
// When montage plays, engine will fire notify at frame 15
// This is AUTHORED DATA - not code yet</code></pre>
            </div>

            <!-- Step 2: Runtime Trigger -->
            <div class="ref-card notify" style="border-left-width: 6px;">
                <h3>ğŸ¬ Step 2: Animation Runtime - LAYER 1</h3>
                <div class="file-path">ğŸ“ Engine Internal (you don't write this)</div>
                <pre><code>// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// INSIDE UE5 ENGINE TICK (Simplified)
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

void UAnimInstance::UpdateAnimation(float DeltaTime)
{
    // Update montage position
    FAnimMontageInstance* MontageInst = GetActiveMontageInstance();
    if (MontageInst)
    {
        MontageInst->Advance(DeltaTime);

        // Check if we passed a notify this frame
        if (MontageInst->Position >= 15.0f && !NotifyFired)
        {
            // Found notify! Get the notify object
            UAnimNotify_OpenHitWindow* Notify = /* ... */;

            // Call the notify's Notify() method
            Notify->Notify(
                GetSkelMeshComponent(),  // The mesh playing anim
                CurrentAnimation,         // The animation asset
                NotifyEventRef           // Context info
            );

            NotifyFired = true;
        }
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ğŸ’¡ What Happened?
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// Engine detects montage reached notify frame
// Engine calls your custom notify's Notify() method
// Now YOUR code runs...</code></pre>
            </div>

            <!-- Step 3: Notify Implementation -->
            <div class="ref-card notify" style="border-left-width: 6px;">
                <h3>ğŸ”” Step 3: Notify Fires - LAYER 1 â†’ LAYER 2</h3>
                <div class="file-path">ğŸ“ AnimNotify_OpenHitWindow.h/.cpp</div>
                <pre><code>// AnimNotify_OpenHitWindow.h
UCLASS()
class MYGAME_API UAnimNotify_OpenHitWindow : public UAnimNotify
{
    GENERATED_BODY()

public:
    UPROPERTY(EditAnywhere, Category="Combat")
    float DamageMultiplier = 1.0f;

    UPROPERTY(EditAnywhere, Category="Combat")
    TSubclassOf&lt;UDamageType&gt; DamageType;

    virtual void Notify(
        USkeletalMeshComponent* MeshComp,
        UAnimSequenceBase* Animation,
        const FAnimNotifyEventReference& EventReference
    ) override;
};

// AnimNotify_OpenHitWindow.cpp
void UAnimNotify_OpenHitWindow::Notify(
    USkeletalMeshComponent* MeshComp,
    UAnimSequenceBase* Animation,
    const FAnimNotifyEventReference& EventReference)
{
    Super::Notify(MeshComp, Animation, EventReference);

    // Safety check - mesh must exist
    if (!MeshComp) return;

    // Get the actor that owns this mesh
    AActor* Owner = MeshComp->GetOwner();
    if (!Owner) return;

    // Find the HitWindowComponent on that actor
    if (auto* HW = Owner->FindComponentByClass&lt;UHitWindowComponent&gt;()) <a class="puzzle-tag" href="/lego/findcomponentbyclass" title="Learn: FindComponentByClass">FindComp</a>
    {
        // Tell it to open the window!
        HW->OpenWindow();
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ğŸ’¡ What Happened?
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 1. Notify gets skeletal mesh component
// 2. Finds owning actor (the character)
// 3. Finds HitWindowComponent on character
// 4. Calls OpenWindow() - next step!</code></pre>
            </div>

            <!-- Step 4: Component Opens Window -->
            <div class="ref-card delegate" style="border-left-width: 6px;">
                <h3>â±ï¸ Step 4: HitWindow Opens & Broadcasts - LAYER 2</h3>
                <div class="file-path">ğŸ“ HitWindowComponent.h/.cpp</div>
                <pre><code>// HitWindowComponent.h
#pragma once
#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "HitWindowComponent.generated.h"

// DECLARE the delegate type - this creates a new C++ type
DECLARE_MULTICAST_DELEGATE(FOnAttackWindow); <a class="puzzle-tag" href="/lego/dynamic-multicast-delegate" title="Learn: Dynamic Multicast Delegate">Delegate</a>

UCLASS(ClassGroup=(Combat), meta=(BlueprintSpawnableComponent))
class MYGAME_API UHitWindowComponent : public UActorComponent
{
    GENERATED_BODY()

public:
    // The delegate INSTANCE - others subscribe to THIS
    FOnAttackWindow OnAttackWindow;

    // Called by AnimNotify to trigger the window
    UFUNCTION(BlueprintCallable, Category="Combat")
    void OpenWindow();

    UFUNCTION(BlueprintCallable, Category="Combat")
    void CloseWindow();

private:
    bool bWindowOpen = false;
};

// HitWindowComponent.cpp
#include "HitWindowComponent.h"

void UHitWindowComponent::OpenWindow()
{
    if (bWindowOpen)
    {
        // Already open, ignore
        return;
    }

    bWindowOpen = true;

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // THIS IS THE KEY LINE! ğŸ”¥
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // Broadcast notifies ALL subscribers
    // No parameters - just a "NOW!" signal
    OnAttackWindow.Broadcast();

    // Could optionally auto-close after delay:
    // GetWorld()->GetTimerManager().SetTimer(...);
}

void UHitWindowComponent::CloseWindow()
{
    bWindowOpen = false;
    // Could have OnAttackWindowClosed delegate here
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ğŸ’¡ What Happened?
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 1. OpenWindow() sets internal flag
// 2. Broadcast() calls ALL subscribed functions
// 3. Remember: HeroCharacter subscribed in Step 0!
// 4. HeroCharacter::HandleAttackWindow() runs NOW</code></pre>
            </div>

            <!-- Step 5: Character Handles -->
            <div class="ref-card pattern" style="border-left-width: 6px;">
                <h3>ğŸ® Step 5: Character Handles Signal - LAYER 3</h3>
                <div class="file-path">ğŸ“ HeroCharacter.cpp - HandleAttackWindow()</div>
                <pre><code>void AHeroCharacter::HandleAttackWindow()
{
    // âš ï¸ MULTIPLAYER: Only server processes damage
    if (!HasAuthority())
    {
        // Client - just play cosmetic effects if needed
        return;
    }

    // The delegate had NO PARAMETERS
    // So WE decide what to do here

    // Query the world for victims in range
    TArray&lt;AActor*&gt; Victims = QueryVictims();

    // Apply damage to each victim found
    for (AActor* Victim : Victims)
    {
        if (!IsValid(Victim)) continue;

        // Find health component on victim
        if (auto* HealthComp = Victim->FindComponentByClass
                &lt;UHealthComponent&gt;())
        {
            // Apply damage
            HealthComp->ApplyDamage(35.f, this);

            // Trigger FX on all clients (optional)
            // Multicast_PlayHitFX(CachedHitLocation, ...);
        }
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ğŸ’¡ What Happened?
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 1. HandleAttackWindow() was called by delegate
// 2. Character queries for victims (next step)
// 3. For each victim, applies damage
// 4. Damage system takes over...</code></pre>
            </div>

            <!-- Step 6: Physics Query -->
            <div class="ref-card trace" style="border-left-width: 6px;">
                <h3>ğŸŒ Step 6: Query Victims (Physics Trace) - LAYER 4</h3>
                <div class="file-path">ğŸ“ HeroCharacter.cpp - QueryVictims()</div>
                <pre><code>TArray&lt;AActor*&gt; AHeroCharacter::QueryVictims()
{
    TArray&lt;AActor*&gt; Results;
    TArray&lt;FHitResult&gt; OutHits;

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // 1. Configure collision query
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    FCollisionQueryParams Params;
    Params.AddIgnoredActor(this);  // Don't hit self
    Params.bTraceComplex = false;  // Use simple collision
    Params.bReturnPhysicalMaterial = true;

#if !UE_BUILD_SHIPPING
    Params.TraceTag = FName("AttackTrace");  // For debug vis
#endif

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // 2. Define sweep shape
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    FCollisionShape Shape = FCollisionShape::MakeSphere(AttackRadius);

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // 3. Calculate start/end positions
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    FVector Start = GetActorLocation() +
        GetActorForwardVector() * 50.f;
    FVector End = Start +
        GetActorForwardVector() * 200.f;

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // 4. Execute sweep trace
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    bool bHit = GetWorld()->SweepMultiByChannel(
        OutHits,                    // OUT: array of hits
        Start,                      // Start position
        End,                        // End position
        FQuat::Identity,            // No rotation
        ECC_GameTraceChannel1,      // Custom "Attack" channel
        Shape,                      // Sphere shape
        Params                      // Query params
    );

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // 5. Process results
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    if (bHit)
    {
        for (const FHitResult& Hit : OutHits)
        {
            if (AActor* HitActor = Hit.GetActor())
            {
                // AddUnique prevents double-hits
                Results.AddUnique(HitActor);
            }
        }
    }

#if !UE_BUILD_SHIPPING
    // Debug visualization
    DrawDebugSphere(GetWorld(), Start, AttackRadius,
        12, bHit ? FColor::Green : FColor::Red,
        false, 0.5f);
#endif

    return Results;
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ğŸ’¡ What Happened?
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 1. Created sphere sweep from character forward
// 2. Engine checked collision with all actors
// 3. Returned array of FHitResult (spatial data)
// 4. Extracted unique actors from hits
// 5. Returns list back to HandleAttackWindow()</code></pre>
            </div>

            <!-- Step 7: Health System -->
            <div class="ref-card health" style="border-left-width: 6px;">
                <h3>â¤ï¸ Step 7: Apply Damage to Health - LAYER 5</h3>
                <div class="file-path">ğŸ“ HealthComponent.h/.cpp</div>
                <pre><code>// HealthComponent.h (relevant parts)
UCLASS(ClassGroup=(Combat), meta=(BlueprintSpawnableComponent))
class MYGAME_API UHealthComponent : public UActorComponent
{
    GENERATED_BODY()

public:
    // Native delegate - C++ only, faster
    DECLARE_MULTICAST_DELEGATE_TwoParams(
        FOnDamagedNative, float, AActor*);
    FOnDamagedNative OnDamagedNative;

    // Dynamic delegate - Blueprint visible
    DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(
        FOnDamagedFX, float, Amount, AActor*, Causer);
    UPROPERTY(BlueprintAssignable, Category="Combat")
    FOnDamagedFX OnDamagedFX;

    DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnDeath);
    UPROPERTY(BlueprintAssignable, Category="Combat")
    FOnDeath OnDeath;

    // Called by attacker to deal damage
    UFUNCTION(BlueprintCallable, Category="Combat")
    void ApplyDamage(float Amount, AActor* DamageCauser);

private:
    UPROPERTY(EditAnywhere, Category="Combat")
    float MaxHealth = 100.f;

    UPROPERTY(ReplicatedUsing=OnRep_Health)
    float Health = 100.f;

    UFUNCTION()
    void OnRep_Health();
};

// HealthComponent.cpp
void UHealthComponent::ApplyDamage(float Amount, AActor* DamageCauser)
{
    // Already dead or invulnerable
    if (Health <= 0.f || !bCanTakeDamage)
    {
        return;
    }

    // Clamp health between 0 and max
    Health = FMath::Clamp(
        Health - Amount,
        0.f,
        MaxHealth
    );

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // Broadcast to C++ systems (fast)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    OnDamagedNative.Broadcast(Amount, DamageCauser);

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // Broadcast to Blueprint systems (slower but flexible)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    OnDamagedFX.Broadcast(Amount, DamageCauser);

    // Check for death
    if (Health <= 0.f)
    {
        OnDeath.Broadcast();
    }
}

void UHealthComponent::OnRep_Health()
{
    // Called on clients when Health replicates from server
    OnHealthChanged.Broadcast(Health);
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ğŸ’¡ What Happened?
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 1. Health reduced and clamped
// 2. TWO delegates broadcast (Native + FX)
// 3. C++ systems respond to Native
// 4. Blueprint/VFX respond to FX
// 5. Death delegate if health hits 0</code></pre>
            </div>

            <!-- Step 8: Native Responders -->
            <div class="ref-card pattern" style="border-left-width: 6px;">
                <h3>âš™ï¸ Step 8: C++ Systems Respond - LAYER 6</h3>
                <div class="file-path">ğŸ“ Various Component Examples</div>
                <pre><code>// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// Example 1: Combo Meter Component
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
void UComboMeterComponent::BeginPlay()
{
    Super::BeginPlay();

    // Find health component and subscribe
    if (auto* HC = GetOwner()->FindComponentByClass
            &lt;UHealthComponent&gt;())
    {
        HC->OnDamagedNative.AddUObject(
            this,
            &UComboMeterComponent::OnDamageDealt
        );
    }
}

void UComboMeterComponent::OnDamageDealt(
    float Amount, AActor* Victim)
{
    ComboCount++;
    LastHitTime = GetWorld()->GetTimeSeconds();

    // Reset combo after 2 seconds of no hits
    GetWorld()->GetTimerManager().SetTimer(
        ComboResetTimer,
        this,
        &UComboMeterComponent::ResetCombo,
        2.0f,
        false
    );

    // Notify UI
    OnComboChanged.Broadcast(ComboCount);
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// Example 2: AI Aggro Manager
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
void UAIAggroManager::OnDamageDealt(
    float Amount, AActor* Victim)
{
    if (AEnemyCharacter* Enemy = Cast&lt;AEnemyCharacter&gt;(Victim))
    {
        // Increase threat toward attacker
        Enemy->AddThreat(GetOwner(), Amount * 1.5f);

        // Alert nearby allies
        AlertNearbyEnemies(Enemy->GetActorLocation(), 1000.f);
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// Example 3: Analytics Subsystem
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
void UCombatAnalytics::OnDamageDealt(
    float Amount, AActor* Victim)
{
    TotalDamageDealt += Amount;
    HitCount++;

    // Track damage by type
    if (LastDamageType == "Fire")
    {
        FireDamageDealt += Amount;
    }

    // Send to analytics backend
    SendDamageEvent(Amount, Victim->GetClass()->GetName());
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ğŸ’¡ What Happened?
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// Multiple C++ systems all subscribed to OnDamagedNative
// When damage occurs, ALL handlers run
// Order is NOT guaranteed - they're independent
// Each system does its own logic</code></pre>
            </div>

            <!-- Step 9: Cosmetic Responders -->
            <div class="ref-card pattern" style="border-left-width: 6px; border-color: #8bc34a;">
                <h3>ğŸ¨ Step 9: Visual/Audio Effects - LAYER 7</h3>
                <div class="file-path">ğŸ“ Blueprint Examples (BP_HitEffects, WBP_DamageNumbers)</div>
                <pre><code>// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// C++ Multicast for Effects (runs on all clients)
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// In HeroCharacter.h
UFUNCTION(NetMulticast, Unreliable)
void Multicast_PlayHitFX(FVector Location, FRotator Rotation);

// In HeroCharacter.cpp
void AHeroCharacter::HandleAttackWindow()
{
    if (!HasAuthority()) return;

    TArray&lt;AActor*&gt; Victims = QueryVictims();

    for (AActor* Victim : Victims)
    {
        if (auto* HC = Victim->FindComponentByClass
                &lt;UHealthComponent&gt;())
        {
            HC->ApplyDamage(35.f, this);

            // Trigger FX on ALL clients (including server)
            Multicast_PlayHitFX(
                CachedHit.ImpactPoint,
                CachedHit.ImpactNormal.Rotation()
            );
        }
    }
}

void AHeroCharacter::Multicast_PlayHitFX_Implementation(
    FVector Location, FRotator Rotation)
{
    // Runs on EVERY client

    // Spawn Niagara particle system
    if (BloodSplatterFX)
    {
        UNiagaraFunctionLibrary::SpawnSystemAtLocation(
            GetWorld(),
            BloodSplatterFX,
            Location,
            Rotation,
            FVector(1.f),  // Scale
            true,          // Auto-destroy
            true           // Auto-activate
        );
    }

    // Play hit sound
    if (HitSound)
    {
        UGameplayStatics::PlaySoundAtLocation(
            this,
            HitSound,
            Location,
            1.0f,  // Volume
            1.0f,  // Pitch
            0.0f,  // Start time
            nullptr,
            nullptr,
            true   // Auto-destroy
        );
    }

    // Camera shake (player only)
    if (APlayerController* PC = Cast&lt;APlayerController&gt;(GetController()))
    {
        PC->ClientStartCameraShake(HitCameraShake);
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// BLUEPRINT: BP_DamageNumberSpawner
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// Event: OnDamagedFX (from HealthComponent)
// â†“
// Create Widget: WBP_DamageNumber
// â†“
// Set Text: Amount (format as string)
// â†“
// Add to Viewport
// â†“
// Play Animation: FloatUp_FadeOut
// â†“
// Remove after 1.5 seconds

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ğŸ’¡ What Happened?
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 1. Server calls Multicast RPC (Unreliable = OK for FX)
// 2. Every client spawns blood VFX at hit location
// 3. Sound plays with 3D attenuation
// 4. Camera shake for local player
// 5. Blueprint spawns floating damage numbers
// 6. All cosmetic - no gameplay impact</code></pre>
            </div>

            <!-- Final Summary -->
            <div class="ref-card pattern" style="border-left-width: 6px; background: rgba(97, 218, 251, 0.05);">
                <h3>âœ… Complete Flow Summary</h3>
                <pre><code>// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// THE FULL PIPELINE (All Layers)
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. [LAYER 0] Artist places AnimNotify_OpenHitWindow at frame 15 in montage
             â†“
2. [LAYER 1] Engine plays montage, detects frame 15 reached
             â†“
3. [LAYER 1] Engine calls Notify() on AnimNotify_OpenHitWindow instance
             â†“
4. [NOTIFY]  Notify finds HitWindowComponent on owner actor
             â†“
5. [LAYER 2] HitWindowComponent::OpenWindow() is called
             â†“
6. [LAYER 2] OnAttackWindow.Broadcast() fires (no parameters)
             â†“
7. [LAYER 3] HeroCharacter::HandleAttackWindow() executes (was subscribed)
             â†“
8. [LAYER 4] Character calls QueryVictims() â†’ SweepMultiByChannel
             â†“
9. [LAYER 4] Physics engine returns TArray&lt;FHitResult&gt; with victims
             â†“
10. [LAYER 3] Character loops through victims
             â†“
11. [LAYER 5] For each victim: HealthComponent::ApplyDamage(35.f, this)
             â†“
12. [LAYER 5] Health clamped, OnDamagedNative.Broadcast(35.f, Attacker)
             â†“
13. [LAYER 6] C++ systems respond: ComboMeter, AI, Analytics, etc.
             â†“
14. [LAYER 5] OnDamagedFX.Broadcast(35.f, Attacker) fires second
             â†“
15. [LAYER 7] Blueprint/VFX respond: Blood, Sounds, Damage numbers, UI
             â†“
16. [DONE]    Combat hit fully processed!

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// KEY INSIGHTS
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âœ… HitWindowComponent is TIMING GATEKEEPER
   - Only job: signal "NOW!" via delegate
   - No damage logic, no traces, no victims

âœ… Delegates enable DECOUPLING
   - HitWindow doesn't know what happens when window opens
   - Character decides to trace
   - Health decides to broadcast to systems
   - Systems don't depend on each other

âœ… Dual Delegate Pattern (Native + FX)
   - OnDamagedNative: C++ gameplay systems (fast)
   - OnDamagedFX: Blueprint/VFX (flexible)
   - Both fire, different audiences

âœ… Multiplayer Safe
   - HasAuthority() checks prevent client cheating
   - Server processes damage
   - Health replicates to clients
   - FX via Multicast RPC to all clients

âœ… Extensible
   - Add new responders without modifying existing code
   - Just subscribe to delegates
   - Open/Closed Principle (SOLID)

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// FILES YOU NEED TO CREATE
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“ Source/YourGame/Combat/
â”œâ”€ HitWindowComponent.h           [Declare delegate, OpenWindow()]
â”œâ”€ HitWindowComponent.cpp          [Implement OpenWindow() + Broadcast]
â”œâ”€ AnimNotify_OpenHitWindow.h      [UCLASS, UPROPERTY params]
â”œâ”€ AnimNotify_OpenHitWindow.cpp    [Notify() finds component, calls OpenWindow]
â”œâ”€ HealthComponent.h               [Dual delegates, ApplyDamage()]
â””â”€ HealthComponent.cpp             [Clamp health, broadcast both delegates]

ğŸ“ Source/YourGame/Characters/
â”œâ”€ HeroCharacter.h                 [BeginPlay, HandleAttackWindow, QueryVictims]
â””â”€ HeroCharacter.cpp               [Subscribe to delegate, trace, apply damage]

ğŸ“ Content/Animations/
â””â”€ AM_SwordSlash.uasset            [Place AnimNotify_OpenHitWindow at frame 15]

ğŸ“ Content/Blueprints/
â””â”€ BP_DamageNumberSpawner.uasset   [Subscribe to OnDamagedFX, spawn UI widgets]

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</code></pre>
            </div>

        </div>
    </div>

    <div class="footer">
        <p>UE5 Combat Architecture Bible v2.0 | Enhanced with Q&A, Networking, Debug Patterns</p>
        <p>Based on Unreal Engine 5 C++ Best Practices | All NOTES contain extended explanations</p>
    </div>
    
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'dark',
            themeVariables: {
                primaryColor: '#1a1a2e',
                primaryTextColor: '#eee',
                primaryBorderColor: '#4a4a6a',
                lineColor: '#61dafb',
                secondaryColor: '#16213e',
                tertiaryColor: '#0f3460',
                noteTextColor: '#000',
                noteBkgColor: '#ffd93d',
                fontSize: '13px'
            },
            flowchart: {
                useMaxWidth: false,
                htmlLabels: true,
                curve: 'basis',
                nodeSpacing: 30,
                rankSpacing: 50
            },
            securityLevel: 'loose'
        });
        
        // Canvas state
        let scale = 0.6; // Start zoomed out to see more
        let panX = 0;
        let panY = 0;
        let isDragging = false;
        let startX, startY;
        
        const container = document.getElementById('diagram-container');
        const canvas = document.getElementById('diagram-canvas');
        const zoomIndicator = document.getElementById('zoom-indicator');
        
        // Apply transform
        function updateTransform() {
            canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
            zoomIndicator.textContent = `${Math.round(scale * 100)}%`;
        }
        
        // Mouse wheel zoom
        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const rect = container.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Zoom factor
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.min(Math.max(0.1, scale * zoomFactor), 5);
            
            // Adjust pan to zoom toward mouse position
            const scaleChange = newScale - scale;
            panX -= (mouseX - panX) * (scaleChange / scale);
            panY -= (mouseY - panY) * (scaleChange / scale);
            
            scale = newScale;
            updateTransform();
        }, { passive: false });
        
        // Mouse drag pan
        container.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return;
            isDragging = true;
            startX = e.clientX - panX;
            startY = e.clientY - panY;
            container.style.cursor = 'grabbing';
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            panX = e.clientX - startX;
            panY = e.clientY - startY;
            updateTransform();
        });
        
        document.addEventListener('mouseup', () => {
            isDragging = false;
            container.style.cursor = 'grab';
        });
        
        container.addEventListener('selectstart', (e) => {
            if (isDragging) e.preventDefault();
        });
        
        function zoomIn() {
            scale = Math.min(scale * 1.2, 5);
            updateTransform();
        }
        
        function zoomOut() {
            scale = Math.max(scale * 0.8, 0.1);
            updateTransform();
        }
        
        function resetZoom() {
            scale = 0.6;
            panX = 20;
            panY = 20;
            updateTransform();
        }
        
        function downloadSVG() {
            const svg = document.querySelector('.mermaid svg');
            const svgData = new XMLSerializer().serializeToString(svg);
            const blob = new Blob([svgData], {type: 'image/svg+xml'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ue5_combat_architecture_v2.svg';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Initialize view
        setTimeout(() => {
            panX = 20;
            panY = 20;
            updateTransform();
        }, 1500);
        
        // Puzzle Tag Navigation
        document.querySelectorAll('.puzzle-tag').forEach(tag => {
            tag.addEventListener('click', (e) => {
                e.preventDefault();
                const href = tag.getAttribute('href');
                // Navigate to the lego piece on the main website
                window.open(href, '_blank');
            });
        });
    </script>
</body>
</html>
