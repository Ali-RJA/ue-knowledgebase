 <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UE5 C++ Common Pieces: The Lego Library</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-deep: #0f172a;
            --bg-card: #1e293b;
            --bg-code: #FCFAF2; /* Creme White */
            --text-code: #1A1A1A; /* Black */
            --accent-blue: #38bdf8;
            --accent-green: #4ade80;
            --accent-purple: #a78bfa;
            --accent-gold: #fbbf24;
            --accent-red: #f87171;
            --accent-cyan: #22d3ee;
            --text-main: #f1f5f9;
            --text-muted: #94a3b8;
            --border: rgba(255, 255, 255, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: var(--bg-deep);
            color: var(--text-main);
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
            overflow-x: hidden;
        }

        /* --- Header Section --- */
        .header {
            padding: 60px 20px;
            text-align: center;
            background: radial-gradient(circle at center, rgba(56, 189, 248, 0.1) 0%, transparent 70%);
            border-bottom: 1px solid var(--border);
        }

        .header h1 {
            font-size: 3rem;
            font-weight: 800;
            letter-spacing: -0.05em;
            margin-bottom: 10px;
            background: linear-gradient(to right, var(--accent-blue), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header p {
            color: var(--text-muted);
            font-size: 1.2rem;
            max-width: 800px;
            margin: 0 auto 30px;
        }

        /* --- Search & Filters --- */
        .controls {
            position: sticky;
            top: 0;
            z-index: 100;
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(12px);
            padding: 15px;
            border-bottom: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .search-container {
            width: 100%;
            max-width: 600px;
            position: relative;
        }

        #searchInput {
            width: 100%;
            padding: 10px 15px;
            border-radius: 10px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: white;
            font-size: 0.95rem;
            transition: all 0.3s;
        }

        #searchInput:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.2);
        }

        .filter-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 6px;
        }

        .filter-btn {
            padding: 5px 12px;
            border-radius: 15px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border);
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .filter-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .filter-btn.active {
            background: var(--accent-blue);
            color: var(--bg-deep);
            font-weight: 600;
            border-color: var(--accent-blue);
        }

        /* --- Grid Layout --- */
        .lego-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 25px;
            padding: 30px;
            max-width: 1600px;
            margin: 0 auto;
            transition: opacity 0.3s ease;
        }

        /* --- Lego Card Style --- */
        .lego-card {
            background: var(--bg-card);
            border-radius: 12px;
            border: 1px solid var(--border);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: transform 0.2s, border-color 0.2s;
            cursor: pointer;
        }

        .lego-card:hover {
            border-color: var(--accent-blue);
            transform: translateY(-4px);
        }

        .code-block {
            background: var(--bg-code);
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--text-code);
            overflow-x: auto;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .code-block pre {
            margin: 0;
            white-space: pre-wrap;
        }

        .mini-graph {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            display: flex;
            justify-content: center;
        }

        .pseudo-code {
            font-size: 0.85rem;
            color: var(--text-muted);
            border-top: 1px solid var(--border);
            padding-top: 10px;
            margin-top: 10px;
        }

        .card-header {
            padding: 12px 15px;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .card-title {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 1rem;
            color: var(--accent-blue);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .card-category {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            background: rgba(255, 255, 255, 0.05);
            padding: 2px 8px;
            border-radius: 4px;
        }

        .card-body {
            padding: 15px;
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        /* --- Detail View --- */
        #detailView {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-deep);
            z-index: 1000;
            overflow-y: auto;
        }

        .detail-container {
            width: 100%;
            max-width: 1400px;
            min-height: 100vh;
            margin: 0 auto;
            background: var(--bg-card);
            border-left: 1px solid var(--border);
            border-right: 1px solid var(--border);
            overflow: hidden;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .detail-header {
            padding: 60px 40px 40px;
            background: linear-gradient(to bottom right, rgba(56, 189, 248, 0.1), transparent);
            border-bottom: 1px solid var(--border);
        }

        .detail-header h2 {
            font-size: 3rem;
            font-weight: 800;
            color: var(--accent-blue);
            font-family: 'JetBrains Mono', monospace;
            letter-spacing: -0.02em;
        }

        .detail-category {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            background: var(--accent-blue);
            color: var(--bg-deep);
            font-weight: 700;
            font-size: 0.8rem;
            text-transform: uppercase;
            margin-bottom: 20px;
        }

        .close-detail {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background 0.2s;
        }

        .close-detail:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* --- Detail Sections --- */
        .detail-section {
            padding: 40px;
            border-bottom: 1px solid var(--border);
        }

        .detail-section:last-child {
            border-bottom: none;
        }

        .section-label {
            display: block;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            color: var(--accent-gold);
            margin-bottom: 20px;
            font-weight: 700;
        }

        /* Mermaid Detail */
        .detail-mermaid {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            padding: 40px;
            overflow-x: auto;
            border: 1px solid var(--border);
        }

        .detail-mermaid svg {
            display: block;
            margin: 0 auto;
            height: auto;
            min-height: 400px;
        }

        /* Code Detail */
        .detail-code-container {
            background: var(--bg-code);
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .code-header-bar {
            padding: 10px 20px;
            background: #e5e7eb;
            border-bottom: 1px solid #d1d5db;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: #4b5563;
            display: flex;
            justify-content: space-between;
        }

        .detail-code {
            padding: 30px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            color: var(--text-code);
            white-space: pre-wrap;
            line-height: 1.5;
        }

        /* Explanation Detail */
        .detail-explanation {
            font-size: 1.1rem;
            color: var(--text-main);
        }

        .detail-explanation p {
            margin-bottom: 15px;
        }

        .detail-explanation ul {
            padding-left: 20px;
            margin-bottom: 15px;
        }

        .detail-explanation li {
            margin-bottom: 10px;
        }

        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .info-card {
            background: rgba(255, 255, 255, 0.03);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        .info-card h4 {
            color: var(--accent-blue);
            margin-bottom: 10px;
            font-size: 0.9rem;
            text-transform: uppercase;
        }

        /* --- Category Colors --- */
        .cat-macros { border-top: 4px solid var(--accent-purple); }
        .cat-lifecycle { border-top: 4px solid var(--accent-green); }
        .cat-comp { border-top: 4px solid var(--accent-blue); }
        .cat-math { border-top: 4px solid var(--accent-gold); }
        .cat-phys { border-top: 4px solid var(--accent-red); }
        .cat-events { border-top: 4px solid var(--accent-cyan); }
        .cat-data { border-top: 4px solid #a855f7; }
        .cat-framework { border-top: 4px solid #ec4899; }
        .cat-ui { border-top: 4px solid #10b981; }
        .cat-cpp { border-top: 4px solid #64748b; }
        .cat-anim { border-top: 4px solid #f43f5e; }
        .cat-ai { border-top: 4px solid #d946ef; }
        .cat-gas { border-top: 4px solid #6366f1; }
        .cat-subsystems { border-top: 4px solid #14b8a6; }
        .cat-input { border-top: 4px solid #8b5cf6; }
        .cat-assets { border-top: 4px solid #f59e0b; }
        .cat-audio { border-top: 4px solid #3b82f6; }
    </style>
</head>
<body>

    <div class="header">
        <h1>ðŸ§± UE5 C++ Common Pieces</h1>
        <p>A modular library of 100+ "Lego Blocks" for Unreal Engine 5.7 development. Built for speed, clarity, and decoupled architecture.</p>
        
        <div class="search-container" style="margin: 0 auto;">
            <input type="text" id="searchInput" placeholder="Search snippets (e.g. 'overlap', 'trace', 'timer')...">
        </div>
    </div>

    <div class="controls">
        <div class="filter-buttons">
            <button class="filter-btn active" data-filter="all">All Pieces</button>
            <button class="filter-btn" data-filter="cat-macros">Macros & Reflection</button>
            <button class="filter-btn" data-filter="cat-lifecycle">Lifecycle & World</button>
            <button class="filter-btn" data-filter="cat-comp">Components & Hierarchy</button>
            <button class="filter-btn" data-filter="cat-math">Math & Space</button>
            <button class="filter-btn" data-filter="cat-phys">Physics & Collision</button>
            <button class="filter-btn" data-filter="cat-events">Delegates & Events</button>
            <button class="filter-btn" data-filter="cat-data">Data & Containers</button>
            <button class="filter-btn" data-filter="cat-framework">Framework & Logic</button>
            <button class="filter-btn" data-filter="cat-ui">UI & Debug</button>
            <button class="filter-btn" data-filter="cat-cpp">C++ Mechanics</button>
            <button class="filter-btn" data-filter="cat-anim">Animation</button>
            <button class="filter-btn" data-filter="cat-ai">AI & Nav</button>
            <button class="filter-btn" data-filter="cat-gas">Ability System</button>
            <button class="filter-btn" data-filter="cat-subsystems">Subsystems</button>
            <button class="filter-btn" data-filter="cat-input">Enhanced Input</button>
            <button class="filter-btn" data-filter="cat-assets">Asset Management</button>
            <button class="filter-btn" data-filter="cat-audio">Audio</button>
        </div>
    </div>

    <div class="lego-grid" id="legoGrid">
        <!-- Pieces will be injected here -->
    </div>

    <!-- Detail View Overlay -->
    <div id="detailView">
        <div class="detail-container">
            <button class="close-detail" onclick="closeDetail()">&times;</button>
            <div id="detailContent">
                <!-- Content injected via JS -->
            </div>
        </div>
    </div>

    <script>
        mermaid.initialize({ 
            theme: 'dark',
            themeVariables: {
                fontSize: '18px',
                fontFamily: 'Inter, system-ui, sans-serif'
            },
            startOnLoad: false,
            securityLevel: 'loose',
            flowchart: { useMaxWidth: false, htmlLabels: true, curve: 'basis' }
        });

        const pieces = [
            // --- I. MACROS & REFLECTION ---
            {
                id: 1,
                title: "UCLASS() & GENERATED_BODY()",
                category: "cat-macros",
                catName: "Macros",
                graph: `flowchart TD
                    H[Header File .h] --> UHT[Unreal Header Tool]
                    UHT --> GCH[generated.h File]
                    UCLASS --"Specifiers"--> UHT
                    GB[GENERATED_BODY] --"Injections"--> GCH
                    UHT --> CDO[Class Default Object]
                    CDO --> Editor[Editor Property Grid]
                    CDO --> Engine[Engine Logic/Spawn]`,
                code: `// MyActor.h
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "MyActor.generated.h" // MUST be the last include

/**
 * UCLASS specifiers:
 * Blueprintable: Can be used as a base for Blueprints
 * BlueprintType: Can be used as a variable in Blueprints
 * Abstract: Cannot be spawned directly
 * Config: Can save properties to .ini files
 */
UCLASS(Blueprintable, BlueprintType, Category="Hattin|Core")
class MYPROJECT_API AMyActor : public AActor
{
    GENERATED_BODY() // Required: Injects reflection boilerplate

public:
    AMyActor();

    // The CDO (Class Default Object) uses values set here
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Settings")
    float InteractionRange = 200.0f;
};`,
                explanation: `
                    <h3>The Reflection Foundation</h3>
                    <p>The <code>UCLASS</code> macro is the gateway to Unreal Engine's reflection system. It tells the <strong>Unreal Header Tool (UHT)</strong> to parse this class and generate the necessary boilerplate code in the <code>.generated.h</code> file.</p>
                    
                    <h4>Core Concepts</h4>
                    <ul>
                        <li><strong>GENERATED_BODY():</strong> This macro must be placed at the very top of your class body. It handles the injection of functions like <code>StaticClass()</code> and allows the engine to manage your object's memory.</li>
                        <li><strong>CDO (Class Default Object):</strong> For every UCLASS, the engine creates one master instance called the CDO. When you spawn a new actor, it is bitwise-copied from this CDO. This is why setting defaults in the constructor is so important.</li>
                        <li><strong>Specifiers:</strong> You can control how the class behaves using specifiers. For example, <code>Abstract</code> prevents designers from accidentally placing a "base" class in the level.</li>
                    </ul>
                    
                    <h4>Safety & Best Practices</h4>
                    <p>Always ensure the <code>#include "YourClassName.generated.h"</code> is the <strong>absolute last include</strong> in your header file. Failing to do so will result in confusing UHT compilation errors.</p>
                `,
                concepts: ["Unreal Header Tool (UHT)", "Class Default Object (CDO)", "Reflection Metadata"],
                practices: ["Last include must be .generated.h", "Use Abstract for base classes", "Limit public variables"]
            },
            {
                id: 2,
                title: "UPROPERTY() Reflection",
                category: "cat-macros",
                catName: "Macros",
                graph: `graph TD
                    Prop[C++ Variable] --> UProp[UPROPERTY]
                    UProp --> Visibility{Visibility}
                    Visibility --> Edit[EditAnywhere / EditDefaultsOnly]
                    Visibility --> View[VisibleAnywhere / VisibleInstanceOnly]
                    UProp --> BP{Blueprint}
                    BP --> RW[BlueprintReadWrite]
                    BP --> RO[BlueprintReadOnly]
                    UProp --> GC[Garbage Collector Tracking]`,
                code: `// Combat variables exposed to Editor
UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Combat", meta = (ClampMin = "0.0"))
float BaseDamage = 25.0f;

// State variable visible but not editable in Editor
UPROPERTY(VisibleInstanceOnly, BlueprintReadOnly, Category = "State")
bool bIsStunned = false;

// Component reference (Must be UPROPERTY for GC safety)
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
TObjectPtr<UStaticMeshComponent> WeaponMesh;`,
                explanation: `
                    <h3>Connecting C++ to the Editor</h3>
                    <p><code>UPROPERTY</code> is the most used macro in Unreal. It serves two critical purposes: exposing variables to the Editor/Blueprints and notifying the <strong>Garbage Collector</strong> that an object is in use.</p>
                    
                    <h4>Visibility vs Editability</h4>
                    <ul>
                        <li><strong>EditAnywhere:</strong> Can be changed in the Archetype (Content Browser) AND on instances in the Level.</li>
                        <li><strong>EditDefaultsOnly:</strong> Can ONLY be changed in the Archetype. Good for balancing global stats.</li>
                        <li><strong>VisibleAnywhere:</strong> You can see the property in the details panel, but not change it (useful for components).</li>
                    </ul>
                    
                    <h4>Garbage Collection Safety</h4>
                    <p>If you have a pointer to a <code>UObject</code> that is NOT a <code>UPROPERTY</code>, the Garbage Collector won't know you're using it and might delete it while your code is still running, leading to <strong>Null Pointer Crashes</strong>.</p>
                `,
                concepts: ["Garbage Collection", "Detail Panels", "Metadata Specifiers"],
                practices: ["Always use UPROPERTY for UObject pointers", "Use TObjectPtr<T> for class members", "Use Categories for organization", "Add ClampMin/Max for designer safety"]
            },
            {
                id: 3,
                title: "UFUNCTION(BlueprintCallable)",
                category: "cat-macros",
                catName: "Macros",
                graph: `graph LR
                    CPP[C++ Function] --"UFUNCTION"--> Reflect[Reflection System]
                    Reflect --> BP[Blueprint Node]
                    BP --"Execution Pin"--> Callable[BlueprintCallable]
                    BP --"Data Pin Only"--> Pure[BlueprintPure]
                    Reflect --> Console[Exec Functions]`,
                code: `// Standard callable function with execution pins
UFUNCTION(BlueprintCallable, Category = "Abilities", meta = (Keywords = "Attack, Swing"))
void PerformMeleeAttack(float PowerMultiplier);

// Pure function (No execution pin, returns data)
UFUNCTION(BlueprintPure, Category = "Abilities")
float GetCurrentStamina() const;

// Console command function
UFUNCTION(Exec)
void Debug_KillAllEnemies();`,
                explanation: `
                    <h3>Exposing Logic to Blueprints</h3>
                    <p><code>UFUNCTION</code> allows your C++ methods to be called from the Blueprint Graph, Console, or over the Network.</p>
                    
                    <h4>Key Specifiers</h4>
                    <ul>
                        <li><strong>BlueprintCallable:</strong> Creates a node with execution pins. Used for actions that change state.</li>
                        <li><strong>BlueprintPure:</strong> For getter functions that don't modify the object. They have no execution pins and look like data wires.</li>
                        <li><strong>Exec:</strong> Allows the function to be called as a command from the in-game console (~ key).</li>
                    </ul>
                    
                    <h4>Performance Note</h4>
                    <p>BlueprintPure functions are called every time their output pin is evaluated. Avoid putting heavy calculations inside Pure functions; use BlueprintCallable and cache the result instead if performance is an issue.</p>
                `,
                concepts: ["Execution Pins", "Pure vs Impure", "Console Commands"],
                practices: ["Use 'const' for Pure functions", "Provide Categories", "Use Keywords for better searchability"]
            },
            {
                id: 4,
                title: "BlueprintNativeEvent",
                category: "cat-macros",
                catName: "Macros",
                graph: `graph TD
                    Call[C++ Call: OnInteract] --> Native{Has BP Override?}
                    Native -- Yes --> BP[Run Blueprint Event Graph]
                    Native -- No --> Implementation[Run _Implementation in C++]
                    BP -- "Optional" --> Super[Add Call to Parent]
                    Super --> Implementation`,
                code: `// --- Header (.h) ---
UFUNCTION(BlueprintNativeEvent, Category = "Interaction")
void OnInteract(AActor* Interactor);

// --- Source (.cpp) ---
// Note: You implement the _Implementation version
void AMyActor::OnInteract_Implementation(AActor* Interactor)
{
    // Default logic: print name of interactor
    if (Interactor)
    {
        UE_LOG(LogTemp, Log, TEXT("Interacted with: %s"), *Interactor->GetName());
    }
}`,
                explanation: `
                    <h3>The Hybrid Event Pattern</h3>
                    <p><code>BlueprintNativeEvent</code> is the most powerful way to bridge C++ and Blueprints. It provides a default C++ implementation while allowing designers to completely override or extend it in Blueprints.</p>
                    
                    <h4>How it Works</h4>
                    <p>When you declare <code>OnInteract</code>, UHT expects you to write a function body for <code>OnInteract_Implementation</code>. When the event is triggered, the engine checks if a Blueprint has an override. If so, it runs the Blueprint; otherwise, it runs the C++ implementation.</p>
                    
                    <h4>The "Add Call To Parent" Feature</h4>
                    <p>In Blueprints, you can right-click the Event node and select <strong>"Add Call To Parent"</strong>. This allows the Blueprint logic to run <em>in addition</em> to the C++ <code>_Implementation</code> code, rather than replacing it.</p>
                `,
                concepts: ["C++/BP Hybrid", "_Implementation Suffix", "Virtual Functions"],
                practices: ["Always provide a default implementation", "Use for logic that designers might want to 'juice' with VFX"]
            },
            {
                id: 5,
                title: "BlueprintImplementableEvent",
                category: "cat-macros",
                catName: "Macros",
                graph: `graph LR
                    CPP[C++ Trigger] --"Fires"--> BP[Empty Node in BP]
                    BP --"Logic Added"--> Results[Visuals/Sounds/Gameplay]
                    CPP --"If not implemented"--> Nothing[Does Nothing]`,
                code: `// --- Header (.h) ---
UFUNCTION(BlueprintImplementableEvent, Category = "Combat")
void OnTakeHeavyDamage(float DamageAmount, FVector HitLocation);

// --- Source (.cpp) ---
// No implementation here!
void AMyActor::ReactToHit()
{
    // C++ purely triggers the event
    OnTakeHeavyDamage(100.0f, GetActorLocation());
}`,
                explanation: `
                    <h3>C++ Triggered, Designer Defined</h3>
                    <p><code>BlueprintImplementableEvent</code> is used when C++ handles the "When" but Blueprints handle the "What". C++ provides no default logic; if the Blueprint doesn't implement the event, nothing happens.</p>
                    
                    <h4>Common Use Cases</h4>
                    <ul>
                        <li><strong>VFX/SFX:</strong> Spawning blood particles or playing a specific sound on impact.</li>
                        <li><strong>UI:</strong> Updating a health bar or triggering a screen shake.</li>
                        <li><strong>Quest logic:</strong> Notifying the Quest System that a specific item was picked up.</li>
                    </ul>
                    
                    <h4>Architecture Tip</h4>
                    <p>This is the ultimate tool for <strong>Decoupling</strong>. Your C++ "Combat System" doesn't need to know about "Particle Systems" or "Sound Waves" â€” it just broadcasts the event and lets the designers handle the rest.</p>
                `,
                concepts: ["Event Driven Design", "Decoupling", "Designer Hooks"],
                practices: ["Use for non-critical visual feedback", "Document the parameters clearly for designers"]
            },
            {
                id: 6,
                title: "UENUM() Enum Definition",
                category: "cat-macros",
                catName: "Macros",
                graph: `graph LR
                    Enum[C++ Enum Class] --> Reflect[UHT Reflection]
                    Reflect --> Dropdown[Blueprint Dropdown]
                    Reflect --> Switch[Switch on Enum Node]
                    Dropdown --> Logic[Branching Gameplay]`,
                code: `UENUM(BlueprintType)
enum class ECombatState : uint8
{
    Idle      UMETA(DisplayName = "Idle/Waiting"),
    Attacking UMETA(DisplayName = "Active Attack"),
    Stunned   UMETA(DisplayName = "Stunned/Disabled"),
    Dead      UMETA(DisplayName = "Deceased")
};

// Usage in class:
UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "State")
ECombatState CurrentState = ECombatState::Idle;`,
                explanation: `
                    <h3>Type-Safe State Management</h3>
                    <p>Enums in Unreal Engine must be <code>enum class</code> and use <code>uint8</code> as the underlying type to be compatible with the reflection system.</p>
                    
                    <h4>Metadata and Display</h4>
                    <p>The <code>UMETA(DisplayName = "...")</code> tag allows you to have clean, readable names in the Editor dropdowns while keeping your C++ code professional and concise.</p>
                    
                    <h4>Bitmasks</h4>
                    <p>You can also use <code>meta = (Bitflags)</code> to allow designers to select multiple options at once (e.g., Damage types: Fire AND Poison), which turns the dropdown into a list of checkboxes.</p>
                `,
                concepts: ["State Machines", "Metadata Names", "Blueprint Type Compatibility"],
                practices: ["Always use enum class", "Use uint8 for reflection", "Add a 'None' or 'Default' state"]
            },
            {
                id: 7,
                title: "USTRUCT() Data Container",
                category: "cat-macros",
                catName: "Macros",
                graph: `graph TD
                    Struct[USTRUCT] --> P1[Damage: float]
                    Struct --> P2[CritChance: float]
                    Struct --> P3[WeaponName: FText]
                    Struct --"Pass by Value"--> BP[Blueprint Variable]
                    BP --"Break"--> Pins[Individual Data Pins]`,
                code: `USTRUCT(BlueprintType)
struct FWeaponStats
{
    GENERATED_BODY()

    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    float BaseDamage = 10.0f;

    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    float FireRate = 1.0f;

    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    FText DisplayName;
};`,
                explanation: `
                    <h3>Bundling Related Data</h3>
                    <p><code>USTRUCT</code> allows you to group related variables into a single package. This makes your code cleaner and allows Blueprints to treat the group as a single variable type.</p>
                    
                    <h4>Reflection in Structs</h4>
                    <p>Just like classes, structs need <code>GENERATED_BODY()</code>. Any variable inside the struct that you want to see in the Editor must have its own <code>UPROPERTY</code> macro.</p>
                    
                    <h4>Passing by Reference</h4>
                    <p>In C++, passing a struct by reference (<code>const FWeaponStats& Stats</code>) is efficient. In Blueprints, you can "Break" a struct to access individual values or "Make" one to bundle data back together.</p>
                `,
                concepts: ["Data Bundling", "Break/Make Nodes", "Value Types"],
                practices: ["Use for complex function arguments", "Prefix with 'F' (e.g., FWeaponStats)", "Keep structs focused and small"]
            },
            {
                id: 8,
                title: "Meta: AllowPrivateAccess",
                category: "cat-macros",
                catName: "Macros",
                graph: `graph LR
                    Priv[Private Variable] --"meta tag"--> BP[Visible in Blueprints]
                    BP --"Design"--> Tweak[Designer can edit]
                    Priv --"Safety"--> CPP[Cannot be accessed by other C++ classes]`,
                code: `private:
    /** The main mesh for the character. Private to ensure encapsulation. */
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components", meta = (AllowPrivateAccess = "true"))
    TObjectPtr<USkeletalMeshComponent> Mesh;

    UPROPERTY(EditDefaultsOnly, Category = "Balance", meta = (AllowPrivateAccess = "true"))
    float SecretMultiplier = 1.5f;`,
                explanation: `
                    <h3>Encapsulation meets Flexibility</h3>
                    <p>Normally, <code>private</code> variables are hidden from the reflection system. <code>AllowPrivateAccess</code> bypasses this, allowing Blueprints to see and edit variables while keeping them protected from other C++ classes.</p>
                    
                    <h4>Why use it?</h4>
                    <p>It follows the <strong>Principle of Least Privilege</strong>. You want your components to be private so they can't be accidentally swapped or deleted by other C++ code, but your designers still need to see them in the Blueprint Component tree.</p>
                    
                    <h4>Best Practice</h4>
                    <p>This is standard for components (Mesh, Camera, SpringArm) in professional UE5 codebases. It enforces good C++ architecture without hindering the design workflow.</p>
                `,
                concepts: ["Encapsulation", "C++/BP Security", "Least Privilege"],
                practices: ["Use for all private components", "Use TObjectPtr for private UObject members", "Keep gameplay-critical variables private but accessible"]
            },
            {
                id: 9,
                title: "Meta: BindWidget (UMG)",
                category: "cat-macros",
                catName: "Macros",
                graph: `graph LR
                    CPP[C++ UserWidget Class] --"Name Match"--> WBP[Widget Blueprint]
                    WBP --"Button named 'AttackBtn'"--> Link[Auto-Link on Construct]
                    Link --> Logic[C++ handles Click Event]`,
                code: `// --- MyUserWidget.h ---
UCLASS()
class UMyUserWidget : public UUserWidget
{
    GENERATED_BODY()

protected:
    // This MUST match the name in the Widget Designer exactly!
    UPROPERTY(meta = (BindWidget))
    TObjectPtr<UButton> AttackButton;

    UPROPERTY(meta = (BindWidgetOptional))
    TObjectPtr<UTextBlock> DescriptionLabel;
};`,
                explanation: `
                    <h3>Automated UI Linking</h3>
                    <p><code>BindWidget</code> is the cleanest way to connect C++ logic to UMG UI elements. When the widget is created, the engine automatically searches for a widget with the same name and assigns it to your pointer.</p>
                    
                    <h4>The Rules</h4>
                    <ul>
                        <li><strong>Exact Name Match:</strong> If your C++ variable is named <code>HPBar</code>, there MUST be a widget named <code>HPBar</code> in the Blueprint.</li>
                        <li><strong>Optional Binding:</strong> If you use <code>BindWidgetOptional</code>, the engine won't complain if the widget is missing. This is great for flexible UI layouts.</li>
                    </ul>
                    
                    <h4>Safety</h4>
                    <p>This prevents "FindWidget" calls and manual casting, making your UI code significantly faster and safer.</p>
                `,
                concepts: ["UMG Integration", "Auto-Wiring", "UI/Logic Separation"],
                practices: ["Use BindWidget for critical UI", "Use TObjectPtr for widget members", "Use BindWidgetOptional for decorative elements", "Validate pointers before use"]
            },
            {
                id: 10,
                title: "Meta: ExposeOnSpawn",
                category: "cat-macros",
                catName: "Macros",
                graph: `graph LR
                    Var[C++ Variable] --"ExposeOnSpawn"--> SpawnNode[SpawnActor Node]
                    SpawnNode --"Input Pin"--> Init[Initialization Data]
                    Init --"Pre-BeginPlay"--> Logic[Immediate use in BeginPlay]`,
                code: `UPROPERTY(EditAnywhere, BlueprintReadOnly, meta = (ExposeOnSpawn = "true"))
int32 TeamID = 0;

UPROPERTY(EditAnywhere, BlueprintReadOnly, meta = (ExposeOnSpawn = "true"))
FVector InitialVelocity;`,
                explanation: `
                    <h3>Initialization at Birth</h3>
                    <p>Setting <code>ExposeOnSpawn</code> adds the variable as an input pin on the "Spawn Actor from Class" node in Blueprints. This allows you to set the value <em>before</em> the actor's <code>BeginPlay</code> runs.</p>
                    
                    <h4>The Lifecycle Advantage</h4>
                    <p>Usually, if you spawn an actor and then set its variables, <code>BeginPlay</code> has already executed using the old default values. With <code>ExposeOnSpawn</code>, the values are ready the instant the actor exists.</p>
                    
                    <h4>Requirements</h4>
                    <p>The variable must also be <code>BlueprintReadOnly</code> or <code>BlueprintReadWrite</code> and <code>EditAnywhere</code> for the pin to appear correctly.</p>
                `,
                concepts: ["Spawning Lifecycle", "Blueprint Nodes", "Initialization Patterns"],
                practices: ["Use for data that BeginPlay depends on", "Essential for 'Team' or 'Owner' assignment"]
            },

            // --- II. LIFECYCLE & WORLD ---
            {
                id: 11,
                title: "BeginPlay()",
                category: "cat-lifecycle",
                catName: "Lifecycle",
                graph: `flowchart TD
                    Spawn[Spawn/Level Load] --> Pac[PostActorCreated]
                    Pac --> PIC[PostInitializeComponents]
                    PIC --> BP[BeginPlay]
                    BP --> Gameplay[Active Gameplay/Tick]`,
                code: `// .h
virtual void BeginPlay() override;

// .cpp
void AMyActor::BeginPlay()
{
    Super::BeginPlay(); // MANDATORY: Call parent logic
    
    // 1. Initialize logic that needs the World
    // 2. Spawn dependent actors
    // 3. Bind to external system delegates
    
    if (GEngine) {
        GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, 
            FString::Printf(TEXT("%s has entered the game!"), *GetName()));
    }
}`,
                explanation: `
                    <h3>The Start of Gameplay</h3>
                    <p><code>BeginPlay</code> is the most common entry point for gameplay logic. It fires once when the actor is spawned into a valid world or when the level starts.</p>
                    
                    <h4>Timing and Safety</h4>
                    <p>Unlike the constructor, <code>BeginPlay</code> is called when the <strong>World</strong> is fully valid. This means it is safe to spawn other actors, find the Player Controller, or query the Physics system.</p>
                    
                    <h4>The Super:: Rule</h4>
                    <p>Failing to call <code>Super::BeginPlay()</code> can break engine-level features. For example, if you're writing a Character, skipping the Super call might prevent the Ability System or AI from initializing correctly.</p>
                `,
                concepts: ["Initialization Order", "World Context", "Virtual Overrides"],
                practices: ["Always call Super::BeginPlay first", "Don't create components here (too late)", "Use for one-time initialization"]
            },
            {
                id: 12,
                title: "Tick(float DeltaTime)",
                category: "cat-lifecycle",
                catName: "Lifecycle",
                graph: `flowchart LR
                    F1[Frame 1] --"Delta: 0.016s"--> F2[Frame 2]
                    F2 --"Delta: 0.033s"--> F3[Frame 3]
                    Tick[Tick Function] --"Uses Delta"--> Consistent[Consistent Speed]`,
                code: `// .h
virtual void Tick(float DeltaTime) override;

// .cpp
void AMyActor::Tick(float DeltaTime)
{
    Super::Tick(DeltaTime);
    
    // Move actor 500 units per second regardless of FPS
    FVector NewLocation = GetActorLocation() + (GetActorForwardVector() * 500.f * DeltaTime);
    SetActorLocation(NewLocation);
}`,
                explanation: `
                    <h3>Frame-by-Frame Updates</h3>
                    <p>The <code>Tick</code> function runs every frame. The <code>DeltaTime</code> parameter is the amount of time (in seconds) that has passed since the last frame.</p>
                    
                    <h4>DeltaTime: The Great Equalizer</h4>
                    <p>If you move an actor by 10 units every tick, a player with 120 FPS will move twice as fast as a player with 60 FPS. By multiplying your movement by <code>DeltaTime</code>, you ensure the actor moves at the same <strong>real-world speed</strong> regardless of the frame rate.</p>
                    
                    <h4>Performance Warning</h4>
                    <p>Tick is expensive. If you have 1000 actors all ticking, your game will lag. Always ask: "Can I do this with a Timer or an Event instead?" If the answer is yes, disable Tick for that actor.</p>
                `,
                concepts: ["Frame-rate Independence", "DeltaTime Calculation", "Game Loop"],
                practices: ["Multiply movement/scaling by DeltaTime", "Disable Tick if not needed (bCanEverTick = false)", "Use Timers for periodic logic"]
            },
            {
                id: 13,
                title: "SpawnActor<T>",
                category: "cat-lifecycle",
                catName: "Lifecycle",
                graph: `flowchart TD
                    Params[Spawn Parameters] --> Spawn[SpawnActor]
                    Class[Class to Spawn] --> Spawn
                    Loc[Location/Rotation] --> Spawn
                    Spawn --> Init[Actor Created]
                    Init --> BP[BeginPlay Called]`,
                code: `// Define spawn parameters
FActorSpawnParameters SpawnParams;
SpawnParams.Owner = this;
SpawnParams.Instigator = GetInstigator();
SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;

FVector Location(0, 0, 100);
FRotator Rotation = FRotator::ZeroRotator;

// Spawn the actor
AMyProjectile* NewProj = GetWorld()->SpawnActor<AMyProjectile>(
    ProjectileClass, 
    Location, 
    Rotation, 
    SpawnParams
);

if (NewProj) {
    // Successfully spawned!
}`,
                explanation: `
                    <h3>Creating Actors at Runtime</h3>
                    <p><code>SpawnActor</code> is the standard way to instantiate new physical objects into the world during gameplay, such as projectiles, enemies, or dropped items.</p>
                    
                    <h4>Spawn Parameters</h4>
                    <p>The <code>FActorSpawnParameters</code> struct allows you to define who "owns" the new actor and how to handle collisions at the spawn point (e.g., "Don't spawn if something is in the way").</p>
                    
                    <h4>Template Safety</h4>
                    <p>Using the <code>SpawnActor&lt;T&gt;</code> template version automatically casts the result to your desired class, preventing the need for manual and potentially unsafe casting later.</p>
                `,
                concepts: ["Object Instantiation", "Memory Allocation", "Spawn Collision Handling"],
                practices: ["Always check if the result is valid (null check)", "Use SpawnActorDeferred if you need to set variables before BeginPlay", "Set the Owner for networking"]
            },
            {
                id: 14,
                title: "FTimerHandle & SetTimer",
                category: "cat-lifecycle",
                catName: "Lifecycle",
                graph: `flowchart LR
                    Start[SetTimer] --"Delay: 2s"--> Exec[Execute Function]
                    Exec --"Looping=true"--> Start
                    Exec --"Looping=false"--> End[Timer Cleared]`,
                code: `FTimerHandle ReticleTimerHandle;

// Call 'ResetReticle' in 1.5 seconds, do not loop
GetWorldTimerManager().SetTimer(
    ReticleTimerHandle, 
    this, 
    &AMyCharacter::ResetReticle, 
    1.5f, 
    false
);

// To stop the timer early:
GetWorldTimerManager().ClearTimer(ReticleTimerHandle);`,
                explanation: `
                    <h3>The High-Performance Delay</h3>
                    <p>Timers are the professional alternative to <code>Tick</code>. They allow you to execute logic at specific intervals or after a delay without running code every single frame.</p>
                    
                    <h4>Why Timers?</h4>
                    <p>If you need to check for enemies every 0.5 seconds, using a looping timer is significantly more efficient than checking in <code>Tick</code> (which might run 120 times per second). Unreal's Timer Manager is highly optimized to handle thousands of timers.</p>
                    
                    <h4>Handle Management</h4>
                    <p>The <code>FTimerHandle</code> is your "receipt". You must keep it if you ever want to check how much time is remaining, pause the timer, or clear it before it fires.</p>
                `,
                concepts: ["Asynchronous Execution", "Performance Optimization", "Handle-based Logic"],
                practices: ["Clear timers in EndPlay to prevent crashes", "Use for fire rates, cooldowns, and status effects", "Avoid 'Delay' nodes in C++ (use timers instead)"]
            },
            {
                id: 15,
                title: "EndPlay(const EEndPlayReason)",
                category: "cat-lifecycle",
                catName: "Lifecycle",
                graph: `flowchart TD
                    Exit[Destroy/Quit/Load] --> Logic[EndPlay]
                    Logic --"Reason: LevelTransition"--> Save[Save Data]
                    Logic --"Reason: Destroyed"--> Clean[Clear Timers/Delegates]
                    Clean --> GC[Garbage Collection]`,
                code: `virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;

void AMyActor::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
    // 1. Clear any active timers
    GetWorldTimerManager().ClearAllTimersForObject(this);
    
    // 2. Unbind from delegates to prevent dangling refs
    OnMyEvent.RemoveAll(this);
    
    // 3. Always call Super at the END
    Super::EndPlay(EndPlayReason);
}`,
                explanation: `
                    <h3>The Graceful Exit</h3>
                    <p><code>EndPlay</code> is the final lifecycle event for an actor. It is called when the actor is being removed from the world for any reason (destruction, level transition, or quitting the game).</p>
                    
                    <h4>Clean Up or Crash</h4>
                    <p>This is your last chance to stop looping timers or unbind from "Multicast Delegates". If a timer tries to call a function on an actor that has been deleted, the game will <strong>Crash</strong>.</p>
                    
                    <h4>The Reason Enum</h4>
                    <p>The <code>EEndPlayReason</code> parameter is very useful. You might want to save the player's position if they are leaving because of a <code>LevelTransition</code>, but not if they are leaving because they <code>Quit</code> or died.</p>
                `,
                concepts: ["Cleanup Phase", "Memory Safety", "Destruction Reasons"],
                practices: ["Always clear timers here", "Always call Super::EndPlay last", "Check the Reason if you have conditional cleanup"]
            },
            {
                id: 16,
                title: "NewObject<T>",
                category: "cat-lifecycle",
                catName: "Lifecycle",
                graph: `flowchart LR
                    Data[Non-Physical Logic] --> NewObj[NewObject]
                    NewObj --> Outer[Set Outer/Owner]
                    Outer --> Mem[Managed by GC]`,
                code: `// Creating a data container during gameplay
UMyInventory* NewInv = NewObject<UMyInventory>(this);

if (NewInv) {
    // NewInv is now managed by the Garbage Collector
    // and its 'Outer' is set to 'this' actor.
}`,
                explanation: `
                    <h3>Instantiating UObjects</h3>
                    <p>Actors (physical objects) use <code>SpawnActor</code>, but classes derived from <code>UObject</code> (pure data/logic) use <code>NewObject</code>.</p>
                    
                    <h4>The 'Outer' Concept</h4>
                    <p>The first parameter of <code>NewObject</code> is the "Outer". This defines the ownership. If the Outer is destroyed, the <code>NewObject</code> becomes eligible for Garbage Collection. Usually, you pass <code>this</code> (the actor creating it) or the <code>GameInstance</code> for global objects.</p>
                    
                    <h4>Garbage Collection</h4>
                    <p>Objects created with <code>NewObject</code> MUST be stored in a <code>UPROPERTY()</code> pointer. If they aren't, the engine will think they are unreferenced and delete them automatically during the next GC cycle.</p>
                `,
                concepts: ["UObject vs AActor", "Ownership (Outer)", "Memory Management"],
                practices: ["Store the result in a UPROPERTY()", "Use for Data Assets, UI logic, or complex state", "Never use 'new' for UObjects"]
            },
            {
                id: 17,
                title: "Destroy()",
                category: "cat-lifecycle",
                catName: "Lifecycle",
                graph: `flowchart TD
                    Kill[Destroy Call] --> State[Marked as PendingKill]
                    State --> End[EndPlay Called]
                    End --> Hidden[Removed from World]
                    Hidden --> GC[GC Reclaims Memory]`,
                code: `void AMyActor::TakeFatalDamage()
{
    // This actor will be removed at the end of the frame
    Destroy();
    
    // Note: The actor still exists in memory until the 
    // next Garbage Collection cycle!
}`,
                explanation: `
                    <h3>Removing Actors</h3>
                    <p><code>Destroy()</code> tells the engine that this actor is no longer needed. It doesn't delete the object from memory instantly; instead, it marks it as "Pending Kill" and removes it from the world at the end of the current frame.</p>
                    
                    <h4>IsPendingKill()</h4>
                    <p>Since the object might stay in memory for a few seconds before the Garbage Collector cleans it up, you should use <code>IsValid(MyActor)</code> or <code>MyActor->IsPendingKill()</code> to check if an actor is still "alive" before talking to it.</p>
                `,
                concepts: ["Garbage Collection", "Lifecycle Termination", "Object Validity"],
                practices: ["Don't use the actor after calling Destroy", "Clean up pointers to this actor in other classes", "Use EndPlay for the actual cleanup logic"]
            },

            // --- III. COMPONENTS & HIERARCHY ---
            {
                id: 21,
                title: "CreateDefaultSubobject",
                category: "cat-comp",
                catName: "Components",
                graph: `flowchart TD
                    Constructor[Actor Constructor] --> CDS[CreateDefaultSubobject]
                    CDS --> CDO[Added to Class Default Object]
                    CDO --> Instance[Present on all Spawns]`,
                code: `// Inside the Actor Constructor (.cpp)
AMyActor::AMyActor()
{
    // Create a mesh component
    MeshComp = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("MainMesh"));
    
    // Set it as the Root (the center of the actor)
    RootComponent = MeshComp;
    
    // Create and attach a spring arm (camera boom)
    SpringArm = CreateDefaultSubobject<USpringArmComponent>(TEXT("SpringArm"));
    SpringArm->SetupAttachment(RootComponent);
}`,
                explanation: `
                    <h3>Building the Actor's Body</h3>
                    <p><code>CreateDefaultSubobject</code> is the only way to create components in an actor's constructor. Components created this way are part of the <strong>Class Default Object (CDO)</strong>, meaning they will exist automatically on every instance of this actor.</p>
                    
                    <h4>The Constructor Rule</h4>
                    <p>You can <strong>ONLY</strong> use this function inside the constructor. If you try to call it in <code>BeginPlay</code>, the game will crash. For creating components during gameplay, you must use <code>NewObject</code> followed by <code>RegisterComponent</code>.</p>
                    
                    <h4>Naming Components</h4>
                    <p>The <code>TEXT()</code> name you provide (e.g., "MainMesh") must be unique within the actor. This name is used by the engine to identify the component in the Blueprint Details panel.</p>
                `,
                concepts: ["CDO (Class Default Object)", "Component Hierarchy", "Memory Pre-allocation"],
                practices: ["Only use in Constructors", "Always set a RootComponent", "Use descriptive TEXT() names"]
            },
            {
                id: 22,
                title: "FindComponentByClass",
                category: "cat-comp",
                catName: "Components",
                graph: `flowchart LR
                    Actor[Target Actor] --"Search"--> Class[Component Type]
                    Class --"Found"--> Pointer[Valid Pointer]
                    Class --"Not Found"--> Null[nullptr]`,
                code: `// Find the health component on another actor
UHealthComponent* Health = OtherActor->FindComponentByClass<UHealthComponent>();

if (Health)
{
    // Actor has health! Apply damage.
    Health->ModifyHealth(-20.0f);
}
else
{
    // This actor doesn't use the health system (e.g., a rock)
}`,
                explanation: `
                    <h3>Modular Communication</h3>
                    <p>Instead of checking "Is this actor an Enemy?", the best practice in UE5 is to check "Does this actor have a Health Component?". This is called <strong>Component-Based Architecture</strong>.</p>
                    
                    <h4>Efficiency</h4>
                    <p>Searching for components is relatively fast, but you shouldn't do it every frame in <code>Tick</code>. If you need to talk to a component frequently, find it once in <code>BeginPlay</code> and store a pointer to it.</p>
                    
                    <h4>Template Usage</h4>
                    <p>The <code>&lt;T&gt;</code> version of the function is the standard. It returns a correctly typed pointer or <code>nullptr</code> if the component doesn't exist, making your code safe and easy to read.</p>
                `,
                concepts: ["Decoupled Logic", "Component Searching", "Type Safety"],
                practices: ["Check for null results", "Cache the result in BeginPlay", "Favor components over deep inheritance"]
            },
            {
                id: 23,
                title: "GetComponentByTag",
                category: "cat-comp",
                catName: "Components",
                graph: `flowchart LR
                    Tag[Tag: 'WeakPoint'] --"Filter"--> Comps[All Components]
                    Comps --"Match"--> Found[Specific Component]`,
                code: `// Get a component by its designer-assigned tag
UActorComponent* WeakPoint = GetSocketComponentByTag(TEXT("WeakPoint"));

// Or find all components with a tag:
TArray<UActorComponent*> FirePoints = GetComponentsByTag(UPrimitiveComponent::StaticClass(), TEXT("Muzzle"));`,
                explanation: `
                    <h3>Identifying Specific Parts</h3>
                    <p>Tags are strings that designers can add to components in the Editor. They are incredibly useful for identifying specific parts of a complex actor without needing hard-coded pointers.</p>
                    
                    <h4>Multi-Part Actors</h4>
                    <p>Imagine a Boss with three "Shield Generators". Instead of creating three variables in C++, you can just look for components with the tag "Generator". This allows designers to add or remove generators without touching the code.</p>
                `,
                concepts: ["Designer/Coder Workflow", "String-based Identification", "Collection Filtering"],
                practices: ["Use FName for tags", "Check array size after searching", "Document required tags for designers"]
            },
            {
                id: 24,
                title: "SetupAttachment",
                category: "cat-comp",
                catName: "Components",
                graph: `flowchart TD
                    Root[Root Mesh] --> Arm[Spring Arm]
                    Arm --> Cam[Camera]
                    Root --> Weapon[Weapon Socket]`,
                code: `// Inside Constructor
MeshComp = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("Mesh"));
RootComponent = MeshComp;

CameraComp = CreateDefaultSubobject<UCameraComponent>(TEXT("Camera"));

// Attach Camera to Mesh
CameraComp->SetupAttachment(RootComponent);

// Attach to a specific bone/socket
WeaponComp->SetupAttachment(RootComponent, TEXT("Hand_R_Socket"));`,
                explanation: `
                    <h3>Defining the Tree</h3>
                    <p><code>SetupAttachment</code> builds the transform hierarchy in the constructor. If the parent component moves, rotates, or scales, the child will follow.</p>
                    
                    <h4>Construction vs Gameplay</h4>
                    <p>You use <code>SetupAttachment</code> <strong>only in the constructor</strong>. If you need to attach something while the game is running (like picking up a sword), you must use <code>AttachToComponent</code> instead.</p>
                    
                    <h4>Sockets</h4>
                    <p>You can attach components to specific "Sockets" defined in a Skeletal Mesh. This is how you place a camera on a character's head or a weapon in their hand.</p>
                `,
                concepts: ["Transform Hierarchy", "Parent/Child Relationships", "Socket-based Attachment"],
                practices: ["Always set a RootComponent first", "Use sockets for character attachments", "Don't use at runtime"]
            },
            {
                id: 25,
                title: "GetCharacterMovement()",
                category: "cat-comp",
                catName: "Components",
                graph: `flowchart LR
                    Move[Character Movement] --> Phys[Gravity/Friction]
                    Move --> State[Walking/Falling/Swimming]
                    Move --> Input[Velocity/Acceleration]`,
                code: `// Tweak movement at runtime
UCharacterMovementComponent* MoveComp = GetCharacterMovement();

if (MoveComp)
{
    MoveComp->MaxWalkSpeed = 800.f; // Sprint
    MoveComp->JumpZVelocity = 1200.f; // High Jump
    MoveComp->GravityScale = 2.0f; // Fast Fall
}`,
                explanation: `
                    <h3>The Movement Powerhouse</h3>
                    <p>The <code>UCharacterMovementComponent</code> is one of the most complex and powerful systems in Unreal. It handles walking, falling, swimming, flying, and even networking (replication/prediction) automatically.</p>
                    
                    <h4>Key Properties</h4>
                    <ul>
                        <li><strong>MaxWalkSpeed:</strong> The top speed of the character.</li>
                        <li><strong>GravityScale:</strong> How much gravity affects this specific character.</li>
                        <li><strong>AirControl:</strong> How much the player can steer while jumping (0.0 to 1.0).</li>
                    </ul>
                    
                    <h4>Networking</h4>
                    <p>This component is built for multiplayer. It handles client-side prediction, meaning the player feels zero lag when moving, even on a slow connection.</p>
                `,
                concepts: ["Locomotion Systems", "Client-Side Prediction", "Physics Constraints"],
                practices: ["Don't try to rewrite movement from scratch", "Tweak BrakingDeceleration for 'snappy' feel", "Use IsFalling() to check jump state"]
            },

            // --- IV. MATH & SPACE ---
            {
                id: 31,
                title: "FVector Math Basics",
                category: "cat-math",
                catName: "Math",
                graph: `flowchart LR
                    V1[Vector A] --"+"--> V2[Vector B]
                    V1 --"*"--> S[Scalar/Float]
                    S --"Result"--> V3[Scaled Distance]`,
                code: `FVector Forward = GetActorForwardVector();
FVector Right = GetActorRightVector();

// 1. Move a point 500 units forward and 200 units right
FVector TargetLocation = GetActorLocation() + (Forward * 500.f) + (Right * 200.f);

// 2. Get distance between two points
float Dist = FVector::Dist(LocA, LocB);

// 3. Get direction from A to B (Normalized)
FVector Dir = (LocB - LocA).GetSafeNormal();`,
                explanation: `
                    <h3>Navigating 3D Space</h3>
                    <p>Unreal uses <code>FVector</code> for positions, directions, and scales. Understanding vector math is essential for almost every gameplay feature.</p>
                    
                    <h4>Common Operations</h4>
                    <ul>
                        <li><strong>Addition:</strong> Offsets a position.</li>
                        <li><strong>Subtraction:</strong> Gets a vector pointing from one object to another.</li>
                        <li><strong>Normalization (GetSafeNormal):</strong> Turns a vector into a "Direction" with a length of 1.0. This is crucial for math involving speeds or rotations.</li>
                    </ul>
                    
                    <h4>Units</h4>
                    <p>In Unreal, 1 unit = 1 centimeter. So 100.0f is exactly 1 meter.</p>
                `,
                concepts: ["Euclidean Space", "Vector Normalization", "Coordinate Systems (X=Forward, Y=Right, Z=Up)"],
                practices: ["Always use GetSafeNormal for directions", "Don't forget Z is Up", "Use FVector::DistSquared for performance optimization"]
            },
            {
                id: 32,
                title: "FMath::FInterpTo (Smooth Move)",
                category: "cat-math",
                catName: "Math",
                graph: `flowchart LR
                    Start[Current Value] --"FInterpTo"--> Target[Target Value]
                    Target --"Smoothness"--> New[Updated Value]`,
                code: `// Inside Tick
// Smoothly update health bar value
CurrentDisplayHealth = FMath::FInterpTo(
    CurrentDisplayHealth, 
    ActualHealth, 
    DeltaTime, 
    5.0f // Interpolation Speed
);`,
                explanation: `
                    <h3>Adding "Juice" with Interpolation</h3>
                    <p>Interpolation (Interp) is the secret to making things feel smooth. Instead of a value snapping instantly from 0 to 100, Interp moves it there gradually over several frames.</p>
                    
                    <h4>The Formula</h4>
                    <p><code>FInterpTo</code> uses an exponential curve. It moves faster when it's far from the target and slows down as it gets closer, creating a natural, professional feel.</p>
                    
                    <h4>Other Types</h4>
                    <ul>
                        <li><strong>VInterpTo:</strong> For smoothly moving FVectors (positions).</li>
                        <li><strong>RInterpTo:</strong> For smoothly rotating FRotators.</li>
                        <li><strong>CInterpTo:</strong> For smoothly changing FColors.</li>
                    </ul>
                `,
                concepts: ["Smoothing Algorithms", "User Experience (Juice)", "Frame-rate Independent Motion"],
                practices: ["Higher speed = snappier transition", "Lower speed = lazier/floatier feel", "Always use DeltaTime"]
            },
            {
                id: 33,
                title: "FRotator (Pitch/Yaw/Roll)",
                category: "cat-math",
                catName: "Math",
                graph: `flowchart TD
                    P[Pitch: Up/Down - Y Axis]
                    Y[Yaw: Left/Right - Z Axis]
                    R[Roll: Tilt/Lean - X Axis]`,
                code: `// Rotate 90 degrees to face East (Yaw)
FRotator NewRotation(0.f, 90.f, 0.f); 
SetActorRotation(NewRotation);

// Get direction vector from rotation
FVector ForwardDir = NewRotation.Vector();

// Combine rotations
FRotator Combined = FRotator(10, 0, 0) + FRotator(0, 45, 0);`,
                explanation: `
                    <h3>Orientation in 3D</h3>
                    <p>Unreal Engine uses Euler Angles (Degrees) for rotations. The <code>FRotator</code> struct contains three values: Pitch, Yaw, and Roll.</p>
                    
                    <h4>The Axes</h4>
                    <ul>
                        <li><strong>Roll (X):</strong> Tilting your head to the side.</li>
                        <li><strong>Pitch (Y):</strong> Looking up and down.</li>
                        <li><strong>Yaw (Z):</strong> Turning your body left and right.</li>
                    </ul>
                    
                    <h4>Gimbal Lock</h4>
                    <p>While FRotator is easy to read, it can suffer from "Gimbal Lock" at extreme angles. For complex physics or space combat, Unreal also supports <strong>FQuat</strong> (Quaternions), which are more stable but much harder for humans to read.</p>
                `,
                concepts: ["Euler Angles", "Local vs World Rotation", "Quaternions (FQuat)"],
                practices: ["Use Yaw for character facing", "Pitch for camera aim", "Use FQuat for complex 360-degree physics"]
            },
            {
                id: 34,
                title: "FVector::DotProduct",
                category: "cat-math",
                catName: "Math",
                graph: `flowchart LR
                    A[My Forward] --"Dot"--> B[Target Direction]
                    B --"> 0"--> Front[In Front]
                    B --"< 0"--> Back[Behind]
                    B --"== 1"--> Parallel[Perfectly Aligned]`,
                code: `FVector MyForward = GetActorForwardVector();
FVector DirToTarget = (TargetLoc - GetActorLocation()).GetSafeNormal();

float Dot = FVector::DotProduct(MyForward, DirToTarget);

if (Dot > 0.7f) 
{ 
    // Target is in a ~45 degree cone in front of me
    UE_LOG(LogTemp, Log, TEXT("I can see the target!")); 
}`,
                explanation: `
                    <h3>Directional Alignment</h3>
                    <p>The Dot Product is a mathematical operation that takes two directions and returns a single number between -1 and 1. It tells you how much two vectors "point in the same direction".</p>
                    
                    <h4>Reading the Result</h4>
                    <ul>
                        <li><strong>1.0:</strong> Vectors are perfectly aligned (same direction).</li>
                        <li><strong>0.0:</strong> Vectors are perpendicular (90 degrees).</li>
                        <li><strong>-1.0:</strong> Vectors are opposite (facing away).</li>
                    </ul>
                    
                    <h4>Use Cases</h4>
                    <p>Commonly used for <strong>Field of View (FOV)</strong> checks, determining if a hit came from the back (backstab), or calculating how much a light source hits a surface.</p>
                `,
                concepts: ["Trigonometry", "Field of View", "Backstab Logic"],
                practices: ["Input vectors MUST be normalized", "0.7 is roughly a 45-degree angle", "Use for AI detection cones"]
            },
            {
                id: 35,
                title: "FMath::Clamp",
                category: "cat-math",
                catName: "Math",
                graph: `flowchart LR
                    Input[Raw Value] --"Clamp(Min, Max)"--> Output[Bounded Result]
                    Output --"Example"--> Health[0% to 100%]`,
                code: `// Ensure health never goes below 0 or above 100
Health = FMath::Clamp(Health + HealingAmount, 0.f, 100.f);

// Clamp for integers
int32 Level = FMath::Clamp(CurrentLevel, 1, 50);`,
                explanation: `
                    <h3>Bounding Values</h3>
                    <p><code>Clamp</code> is a simple but vital function that forces a value to stay within a specific range. If the value is higher than the max, it returns the max. If it's lower than the min, it returns the min.</p>
                    
                    <h4>Safety First</h4>
                    <p>Always use Clamp when modifying gameplay stats like Health, Mana, or Speed. Without it, a powerful healing spell could give a player 5,000% health, potentially breaking your UI or logic elsewhere.</p>
                `,
                concepts: ["Boundary Safety", "Data Sanitization", "Range Validation"],
                practices: ["Use for all player stats", "Essential for UI progress bars", "Prevents 'Out of Bounds' errors"]
            },
            {
                id: 36,
                title: "FindLookAtRotation",
                category: "cat-math",
                catName: "Math",
                graph: `flowchart LR
                    Start[My Location] --"Math"--> End[Target Location]
                    End --"Rotation"--> Result[Required Facing Direction]`,
                code: `// Get the rotation needed to face an enemy
FRotator LookAtRot = UKismetMathLibrary::FindLookAtRotation(
    GetActorLocation(), 
    EnemyLocation
);

// We usually only want to rotate the Yaw (Z)
LookAtRot.Pitch = 0.f;
LookAtRot.Roll = 0.f;

SetActorRotation(LookAtRot);`,
                explanation: `
                    <h3>Aiming and Facing</h3>
                    <p>This function calculates the rotation required to point an object's X-axis (Forward) directly at a target position.</p>
                    
                    <h4>Usage in AI</h4>
                    <p>This is the bread and butter of AI behavior. When an NPC is chasing you, the engine is constantly calculating a "LookAtRotation" to ensure they are facing their target while running.</p>
                    
                    <h4>The Z-Axis Lock</h4>
                    <p>When using this for characters walking on the ground, you almost always want to set <code>Pitch</code> and <code>Roll</code> to 0 after the calculation. Otherwise, the character might tilt awkwardly up or down if the target is on a different elevation.</p>
                `,
                concepts: ["Targeting", "NPC Orientation", "Coordinate Transformation"],
                practices: ["Zero out Pitch/Roll for ground characters", "Combine with RInterpTo for smooth turning", "Use for turrets and look-at constraints"]
            },
            {
                id: 37,
                title: "FTransform (Pos/Rot/Scale)",
                category: "cat-math",
                catName: "Math",
                graph: `flowchart TD
                    T[FTransform] --> L[Location: FVector]
                    T --> R[Rotation: FQuat]
                    T --> S[Scale: FVector]
                    T --"Multiply"--> Combined[Combined Transforms]`,
                code: `// Capture current transform
FTransform MyTM = GetActorTransform();

// Modify only scale
MyTM.SetScale3D(FVector(2.0f, 2.0f, 2.0f));

// Spawn actor using the transform
GetWorld()->SpawnActor<AMyActor>(ActorClass, MyTM);

// Convert a local point to a world point
FVector WorldPoint = MyTM.TransformPosition(FVector(100, 0, 0));`,
                explanation: `
                    <h3>The Complete 3D State</h3>
                    <p>While an actor's position and rotation are often used separately, they are stored together in an <code>FTransform</code>. This struct holds the Location, Rotation (as a Quaternion), and Scale.</p>
                    
                    <h4>The Power of Transformation</h4>
                    <p>FTransform allows you to convert points between <strong>Local Space</strong> and <strong>World Space</strong>. For example, if you want to spawn an effect "1 meter in front of the player's chest," you take the player's transform and use <code>TransformPosition</code> on a local vector like (100, 0, 50).</p>
                    
                    <h4>Performance</h4>
                    <p>Multiplication of transforms is mathematically efficient. You can multiply a "Hand Transform" by a "Sword Offset Transform" to get the "Sword World Transform" in a single line.</p>
                `,
                concepts: ["Matrix Math", "Local vs World Space", "Spatial State"],
                practices: ["Use for spawning and teleporting", "Essential for bone-space calculations", "Use TransformPosition for relative offsets"]
            },

            // --- V. PHYSICS & COLLISION ---
            {
                id: 41,
                title: "LineTraceSingleByChannel",
                category: "cat-phys",
                catName: "Physics",
                graph: `flowchart LR
                    Start[Start Location] --"Trace Vector"--> End[End Location]
                    End --"Hit Something?"--> Result{FHitResult}
                    Result --"Yes"--> Data[Actor, Location, Normal]
                    Result --"No"--> Fail[Return False]`,
                code: `FHitResult Hit;
FVector Start = GetActorLocation();
FVector End = Start + (GetActorForwardVector() * 1000.f);

// Collision query parameters
FCollisionQueryParams Params;
Params.AddIgnoredActor(this); // Don't hit yourself

bool bHit = GetWorld()->LineTraceSingleByChannel(
    Hit, 
    Start, 
    End, 
    ECC_Visibility, 
    Params
);

if (bHit)
{
    AActor* HitActor = Hit.GetActor();
    FVector HitPoint = Hit.ImpactPoint;
    // Draw a debug line to see the trace
    DrawDebugLine(GetWorld(), Start, HitPoint, FColor::Red, false, 1.0f);
}`,
                explanation: `
                    <h3>The "Laser Beam" Scan</h3>
                    <p>Line Tracing (also called Raycasting) is the primary way to "see" things in the physics world. You shoot an invisible line between two points and the engine tells you the first thing it hits.</p>
                    
                    <h4>FHitResult: The Data Bundle</h4>
                    <p>When a trace hits something, it returns an <code>FHitResult</code>. This contains vital information: what was hit (<code>GetActor()</code>), where it was hit (<code>ImpactPoint</code>), and the angle of the surface (<code>ImpactNormal</code>).</p>
                    
                    <h4>Collision Channels</h4>
                    <p>The <code>ECC_Visibility</code> parameter defines which "Channel" the trace uses. You can set objects to "Ignore" or "Block" specific channels. For example, a ghost might block the <code>ECC_Visibility</code> channel but ignore the <code>ECC_Camera</code> channel.</p>
                `,
                concepts: ["Raycasting", "Collision Filtering", "Impact Analysis"],
                practices: ["Always use AddIgnoredActor(this)", "Use DrawDebugLine for debugging", "Check bHit before accessing Hit data"]
            },
            {
                id: 42,
                title: "OnComponentBeginOverlap",
                category: "cat-phys",
                catName: "Physics",
                graph: `flowchart LR
                    A[Actor A] --"Enters Volume"--> B[Trigger Volume]
                    B --"Delegate Fires"--> C[C++ Logic]
                    C --"Filter"--> D[Apply Damage/Effect]`,
                code: `// .h
UFUNCTION()
void OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, 
    UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, 
    bool bFromSweep, const FHitResult& SweepResult);

// .cpp - Usually in BeginPlay or Constructor
TriggerCapsule->OnComponentBeginOverlap.AddDynamic(this, &AMyActor::OnOverlapBegin);

void AMyActor::OnOverlapBegin(...)
{
    if (OtherActor && OtherActor != this)
    {
        UE_LOG(LogTemp, Warning, TEXT("Overlap with: %s"), *OtherActor->GetName());
    }
}`,
                explanation: `
                    <h3>Trigger Zones and Overlaps</h3>
                    <p>Overlaps are used for "Trigger Zones" where you want to detect when an object enters an area without physically blocking it (like a pressure plate or a poison cloud).</p>
                    
                    <h4>The UFUNCTION Requirement</h4>
                    <p>Because this uses a <strong>Dynamic Delegate</strong>, the function you bind MUST have the <code>UFUNCTION()</code> macro. If you forget it, the binding will fail silently and the event will never fire.</p>
                    
                    <h4>Filtering</h4>
                    <p>Always check that <code>OtherActor</code> is not <code>nullptr</code> and is not <code>this</code> (yourself). You can also use <code>OtherActor->IsA(ACharacter::StaticClass())</code> to ensure only players trigger the event.</p>
                `,
                concepts: ["Trigger Volumes", "Dynamic Delegates", "Event Filtering"],
                practices: ["Always use UFUNCTION() for the handler", "Check for null OtherActor", "Use for non-blocking detection"]
            },
            {
                id: 43,
                title: "SweepSingleByProfile",
                category: "cat-phys",
                catName: "Physics",
                graph: `flowchart LR
                    Shape[Sphere/Box/Capsule] --"Moved From A to B"--> Path[Sweep Volume]
                    Path --"Collision"--> Hit[FHitResult]`,
                code: `FHitResult Hit;
FVector Start = GetActorLocation();
FVector End = Start + (GetActorForwardVector() * 500.f);
FQuat Rot = GetActorQuaternion();

// Define a sphere with 50cm radius
FCollisionShape Sphere = FCollisionShape::MakeSphere(50.f);

bool bHit = GetWorld()->SweepSingleByProfile(
    Hit, 
    Start, 
    End, 
    Rot, 
    TEXT("Projectile"), 
    Sphere
);`,
                explanation: `
                    <h3>Traces with "Thickness"</h3>
                    <p>A Line Trace is an infinitely thin line. A <strong>Sweep</strong> is a 3D shape (Sphere, Box, or Capsule) being pushed through space. This is much more accurate for projectiles or melee weapons.</p>
                    
                    <h4>Why use Sweeps?</h4>
                    <p>If you use a Line Trace for a bullet, it might miss a fast-moving enemy because the line was too thin. A Sphere Sweep ensures that if any part of the bullet's "body" touches the enemy, a hit is recorded.</p>
                    
                    <h4>Profiles</h4>
                    <p><code>SweepSingleByProfile</code> uses a named "Collision Profile" (like "Projectile" or "Pawn") instead of a channel. This is often cleaner because profiles bundle many channel responses together.</p>
                `,
                concepts: ["Volume Casting", "Collision Shapes", "Profile-based Filtering"],
                practices: ["Use for large projectiles", "Essential for melee combat detection", "Check profile names in Project Settings"]
            },
            {
                id: 44,
                title: "OverlapMultiByObjectType",
                category: "cat-phys",
                catName: "Physics",
                graph: `flowchart TD
                    Center[Sphere Center] --"Radius Scan"--> Search[Search World]
                    Search --"Filter: Pawns"--> Results[Array of Actors]
                    Results --"Iterate"--> Logic[Apply AoE Damage]`,
                code: `TArray<FOverlapResult> Overlaps;
FVector Origin = GetActorLocation();
float Radius = 500.f;

// Only look for Pawns (Players/AI)
FCollisionObjectQueryParams ObjectParams;
ObjectParams.AddObjectTypesToQuery(ECC_Pawn);

bool bFound = GetWorld()->OverlapMultiByObjectType(
    Overlaps, 
    Origin, 
    FQuat::Identity, 
    ObjectParams, 
    FCollisionShape::MakeSphere(Radius)
);

for (const FOverlapResult& Result : Overlaps)
{
    AActor* OverlappedActor = Result.GetActor();
    // Do something to each actor in range...
}`,
                explanation: `
                    <h3>Area of Effect (AoE) Scans</h3>
                    <p>When you need to find <strong>all</strong> objects in an area (like an explosion or a radar ping), you use a "Multi" overlap function.</p>
                    
                    <h4>Object Types vs Channels</h4>
                    <p><code>OverlapMultiByObjectType</code> is particularly efficient because it only scans for specific physics types (WorldStatic, Pawn, PhysicsBody). This is much faster than scanning every single object in the world.</p>
                    
                    <h4>Performance</h4>
                    <p>While very useful, "Multi" scans are heavier than "Single" scans. Avoid running large-radius Multi overlaps every frame in <code>Tick</code>. Use a timer or trigger them only when an event occurs.</p>
                `,
                concepts: ["AoE (Area of Effect)", "Physics Object Types", "Spatial Queries"],
                practices: ["Use for explosions and proximity sensors", "Iterate results with a for-loop", "Limit the scan radius"]
            },
            {
                id: 45,
                title: "AddForce / AddImpulse",
                category: "cat-phys",
                catName: "Physics",
                graph: `flowchart LR
                    Force[Force] --"Over Time"--> Accel[Acceleration]
                    Impulse[Impulse] --"Instant"--> Velocity[Velocity Change]
                    Actor[Physics Actor] --"Reacts"--> Motion`,
                code: `// 1. A continuous push (e.g., wind or a rocket)
Mesh->AddForce(FVector(1000.f, 0, 0));

// 2. An instant kick (e.g., an explosion or a jump)
Mesh->AddImpulse(FVector(0, 0, 500.f), NAME_None, true); 

// The 'true' parameter ignores mass (VelocityChange)
// Use this if you want the same kick regardless of weight.`,
                explanation: `
                    <h3>Applying Physical Power</h3>
                    <p>To move objects using Unreal's physics engine (PhysX/Chaos), you apply Forces or Impulses. The object must have <strong>"Simulate Physics"</strong> enabled.</p>
                    
                    <h4>Force vs Impulse</h4>
                    <ul>
                        <li><strong>Force:</strong> Applied every frame (usually in Tick). Best for constant movement like wind or thrusters.</li>
                        <li><strong>Impulse:</strong> A one-time burst of energy. Best for "hits," explosions, or jumping.</li>
                    </ul>
                    
                    <h4>The Mass Variable</h4>
                    <p>By default, heavy objects move less than light ones. If you want a "superpower" that knocks back everyone the same distance, use <code>bVelChange = true</code> to ignore the object's mass.</p>
                `,
                concepts: ["Newtonian Physics", "Acceleration", "Velocity Change"],
                practices: ["Objects must have Simulate Physics enabled", "Use Force for continuous motion", "Use Impulse for sudden impacts"]
            },
            {
                id: 46,
                title: "Collision Profiles",
                category: "cat-phys",
                catName: "Physics",
                graph: `flowchart TD
                    Prof[Profile: 'Pawn'] --> Ch1[Visibility: Ignore]
                    Prof --> Ch2[Camera: Overlap]
                    Prof --> Ch3[WorldStatic: Block]
                    Actor[Actor] --"Assigned"--> Prof`,
                code: `// Change the entire collision behavior at once
Mesh->SetCollisionProfileName(TEXT("OverlapAll"));

// Or tweak specific responses
Mesh->SetCollisionResponseToChannel(ECC_Pawn, ECR_Block);
Mesh->SetCollisionResponseToAllChannels(ECR_Ignore);`,
                explanation: `
                    <h3>Managing Physics Rules</h3>
                    <p>Collision Profiles are "Presets" that define how an object interacts with every other object in the game. Instead of setting 20 different checkboxes manually, you just select a profile like "Pawn" or "BlockAll".</p>
                    
                    <h4>Response Types</h4>
                    <ul>
                        <li><strong>Ignore:</strong> Pass through without even noticing.</li>
                        <li><strong>Overlap:</strong> Pass through, but fire an event (BeginOverlap).</li>
                        <li><strong>Block:</strong> Physically stop the movement.</li>
                    </ul>
                    
                    <h4>Custom Profiles</h4>
                    <p>You can define your own profiles in <strong>Project Settings -> Collision</strong>. For example, a "Bullet" profile might be set to block Pawns but ignore foliage.</p>
                `,
                concepts: ["Collision Matrix", "Interaction Presets", "Physics Optimization"],
                practices: ["Use profiles instead of manual overrides", "Use 'Query Only' for triggers", "Use 'Physics Only' for background clutter"]
            },

            // --- VI. DELEGATES & EVENTS ---
            {
                id: 51,
                title: "Dynamic Multicast Delegate",
                category: "cat-events",
                catName: "Events",
                graph: `flowchart TD
                    Source[One Source Event] --"Broadcast"--> L1[Listener A: UI]
                    Source --"Broadcast"--> L2[Listener B: Audio]
                    Source --"Broadcast"--> L3[Listener C: Blueprint]`,
                code: `// .h
// 1. Declare the delegate type (outside class)
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnHealthChanged, float, NewHealth);

UCLASS()
class AMyActor : public AActor {
    GENERATED_BODY()
public:
    // 2. Create the broadcast variable
    UPROPERTY(BlueprintAssignable, Category = "Events")
    FOnHealthChanged OnHealthChanged;

    void TakeDamage(float Amt) {
        CurrentHP -= Amt;
        // 3. Fire the event!
        OnHealthChanged.Broadcast(CurrentHP);
    }
};`,
                explanation: `
                    <h3>The Radio Broadcast Pattern</h3>
                    <p>Delegates are Unreal's implementation of the <strong>Observer Pattern</strong>. A class can "Broadcast" an event, and any number of other classes can "Listen" to it without being tightly coupled.</p>
                    
                    <h4>Why Multicast?</h4>
                    <p>A "Single" delegate can only have one listener. A "Multicast" delegate can have hundreds. This is perfect for something like a "Player Death" event, where the UI needs to show a screen, the Sound system needs to play a sad song, and the GameMode needs to restart the level.</p>
                    
                    <h4>BlueprintAssignable</h4>
                    <p>By adding this specifier, designers can see the event in the Blueprint Editor and use the <strong>"Bind Event"</strong> node to add logic without touching C++.</p>
                `,
                concepts: ["Observer Pattern", "Decoupling", "Event-Driven Programming"],
                practices: ["Use for game-wide notifications", "Add 'F' prefix to delegate types", "Check IsBound() for single delegates (not needed for multicast)"]
            },
            {
                id: 52,
                title: "AddDynamic (Binding)",
                category: "cat-events",
                catName: "Events",
                graph: `flowchart LR
                    Source[Event Source] --"Bind"--> Target[My C++ Class]
                    Target --"AddDynamic"--> Handler[UFUNCTION Handler]
                    Source --"Fires"--> Handler`,
                code: `// Inside BeginPlay
// Connect my 'HandleDeath' function to the Boss's 'OnDeath' event
BossActor->OnDeath.AddDynamic(this, &AMyActor::HandleBossDeath);

// The Handler MUST be a UFUNCTION
UFUNCTION()
void HandleBossDeath(AActor* DeadBoss)
{
    UE_LOG(LogTemp, Log, TEXT("Victory! %s is dead."), *DeadBoss->GetName());
}`,
                explanation: `
                    <h3>Listening to Events</h3>
                    <p><code>AddDynamic</code> is the helper macro used to bind a C++ function to a <strong>Dynamic Multicast Delegate</strong>. It allows your class to "subscribe" to notifications from another object.</p>
                    
                    <h4>The UFUNCTION Rule</h4>
                    <p>Any function being bound via <code>AddDynamic</code> <strong>MUST</strong> have the <code>UFUNCTION()</code> macro. This is because dynamic delegates use Unreal's reflection system to find and call the function by name.</p>
                    
                    <h4>Safe Unbinding</h4>
                    <p>It is good practice to call <code>RemoveDynamic</code> in <code>EndPlay</code>, although the engine is usually smart enough to clean up bindings when an object is destroyed.</p>
                `,
                concepts: ["Subscription Model", "Function Pointers", "Reflection-based Binding"],
                practices: ["Bind in BeginPlay", "Always use UFUNCTION()", "Check if the source actor is valid before binding"]
            },
            {
                id: 53,
                title: "TFunction (Lambdas)",
                category: "cat-events",
                catName: "Events",
                graph: `flowchart LR
                    Logic[Inline Function Code] --"Captured"--> Var[TFunction Variable]
                    Var --"Executed"--> Run[Run Logic Anywhere]`,
                code: `// Define a function on the fly!
TFunction<void(int32)> MySuccessCallback = [this](int32 NewID)
{
    this->GeneratedID = NewID;
    UE_LOG(LogTemp, Log, TEXT("ID received: %d"), NewID);
};

// Pass it to an async task or sorting function
SomeAsyncObject->DoWork(MySuccessCallback);`,
                explanation: `
                    <h3>Anonymous Functions</h3>
                    <p>Sometimes you need a quick bit of logic that doesn't deserve its own named function in the header file. This is where <strong>Lambdas</strong> and <code>TFunction</code> come in.</p>
                    
                    <h4>Capturing ( [this] )</h4>
                    <p>The brackets <code>[]</code> define the "Capture Group". By putting <code>this</code> inside, the lambda gains access to all the variables and functions of your class. Be careful: if you capture <code>this</code> and your object is destroyed before the lambda runs, the game will crash!</p>
                    
                    <h4>Use Cases</h4>
                    <p>Lambdas are perfect for <strong>TArray Sorting</strong>, <strong>Filtering</strong>, or <strong>Asynchronous Callbacks</strong> (e.g., code that should run after a web request finishes).</p>
                `,
                concepts: ["Functional Programming", "Scope Capturing", "Inline Logic"],
                practices: ["Use for small, one-off logic", "Be careful with 'this' capture in async code", "Keep them short for readability"]
            },
            {
                id: 54,
                title: "Super::Function()",
                category: "cat-events",
                catName: "Events",
                graph: `flowchart TD
                    Child[My Character: Jump] --> Parent[ACharacter: Jump]
                    Parent --> Grand[AActor: Jump]
                    Grand --> Engine[Engine Internal Logic]`,
                code: `void AMyPlayer::BeginPlay()
{
    // 1. ALWAYS call parent logic first for Lifecycle
    Super::BeginPlay(); 
    
    // 2. Then add your custom logic
    SetupHealthUI();
}

void AMyPlayer::Jump()
{
    // Custom logic: cost stamina to jump
    if (Stamina > 10.f) {
        Stamina -= 10.f;
        Super::Jump(); // Run actual engine jump
    }
}`,
                explanation: `
                    <h3>Inheriting Engine Power</h3>
                    <p>In C++, <code>Super</code> is a shorthand for "the class I inherited from". Calling <code>Super::FunctionName()</code> ensures that you don't accidentally "overwrite" critical engine logic.</p>
                    
                    <h4>The "Black Box" Logic</h4>
                    <p>When you override <code>Jump()</code> in a Character, the actual physics of jumping (velocity changes, animation triggers) live inside the parent <code>ACharacter::Jump()</code>. If you forget to call Super, your character will simply stand still when you press the jump button.</p>
                    
                    <h4>Placement Matters</h4>
                    <ul>
                        <li><strong>At the start:</strong> Usual for lifecycle events like <code>BeginPlay</code> or <code>Tick</code>.</li>
                        <li><strong>At the end:</strong> Usual for cleanup events like <code>EndPlay</code>.</li>
                        <li><strong>Conditional:</strong> Only call Super if your custom check passes.</li>
                    </ul>
                `,
                concepts: ["Method Overriding", "Class Hierarchy", "Boilerplate Safety"],
                practices: ["Always call Super for Lifecycle methods", "Call Super first in BeginPlay", "Call Super last in EndPlay"]
            },

            // --- VII. DATA & CONTAINERS ---
            {
                id: 61,
                title: "TSoftObjectPtr (Async Loading)",
                category: "cat-data",
                catName: "Data",
                graph: `flowchart LR
                    Ptr[Soft Object Pointer] --"Path Only"--> Mem[Low Memory]
                    Mem --"LoadSynchronous"--> Asset[Full Asset in RAM]
                    Mem --"Async Load"--> Registry[Streamable Manager]`,
                code: `// .h
UPROPERTY(EditAnywhere, Category = "Assets")
TSoftObjectPtr<UStaticMesh> HeavyMeshPtr;

// .cpp
void AMyActor::LoadMesh()
{
    if (HeavyMeshPtr.IsPending())
    {
        // 1. Sync Load (Causes small hitch)
        UStaticMesh* LoadedMesh = HeavyMeshPtr.LoadSynchronous();
        MeshComp->SetStaticMesh(LoadedMesh);
    }
}`,
                explanation: `
                    <h3>Memory-Safe References</h3>
                    <p>Normally, a <code>UStaticMesh*</code> pointer is a "Hard Reference". This means if you load an actor that uses that mesh, the mesh is loaded into memory instantly. <code>TSoftObjectPtr</code> is a "Soft Reference" â€” it only stores the string path to the asset.</p>
                    
                    <h4>Preventing Hitches</h4>
                    <p>If you have a game with 1,000 different swords, you don't want to load all 1,000 models when the game starts. You use Soft Pointers to load only the sword the player is currently holding.</p>
                    
                    <h4>Async Loading</h4>
                    <p>The real power comes when combined with the <code>FStreamableManager</code>. You can request a load, keep playing the game, and get a callback when the asset is ready, ensuring a perfectly smooth frame rate.</p>
                `,
                concepts: ["Lazy Loading", "Memory Management", "Asset Registry"],
                practices: ["Use for large textures/meshes", "Essential for open-world games", "Check IsValid() after loading"]
            },
            {
                id: 62,
                title: "TArray Basics",
                category: "cat-data",
                catName: "Data",
                graph: `flowchart LR
                    A[TArray] --> I0[Index 0: Item]
                    A --> I1[Index 1: Item]
                    A --> I2[Index 2: Item]
                    A --"Add/Remove"--> Resize[Dynamic Resizing]`,
                code: `TArray<AActor*> NearbyEnemies;

// 1. Adding items
NearbyEnemies.Add(NewEnemy);
NearbyEnemies.AddUnique(NewEnemy); // Only adds if not already there

// 2. Removing items
NearbyEnemies.Remove(OldEnemy);
NearbyEnemies.RemoveAt(0);

// 3. Information
int32 Count = NearbyEnemies.Num();
bool bEmpty = NearbyEnemies.IsEmpty();

// 4. Iteration
for (AActor* Enemy : NearbyEnemies) { ... }`,
                explanation: `
                    <h3>The Standard List</h3>
                    <p><code>TArray</code> is the most used container in Unreal Engine. It's a dynamically resizing array that stores items in a continuous block of memory, making it extremely fast to iterate through.</p>
                    
                    <h4>Performance</h4>
                    <p>Because the memory is continuous, <code>TArray</code> is cache-friendly. However, removing an item from the middle of a large array can be slow because all subsequent items must be shifted to fill the gap.</p>
                    
                    <h4>Blueprint Compatibility</h4>
                    <p>If a <code>TArray</code> is marked as a <code>UPROPERTY</code>, it shows up as an "Array" in Blueprints, allowing designers to easily add or remove items in the Editor.</p>
                `,
                concepts: ["Dynamic Arrays", "Cache Locality", "Index-based Access"],
                practices: ["Use for most lists", "Reserve memory if you know the size (Shrink/Empty)", "Prefer AddUnique for sets of items"]
            },
            {
                id: 63,
                title: "TMap (Key-Value Pairs)",
                category: "cat-data",
                catName: "Data",
                graph: `flowchart LR
                    Key["Key: 'Player1'"] --"Lookup"--> Value["Value: Score(500)"]
                    Key2["Key: 'Player2'"] --"Lookup"--> Value2["Value: Score(1200)"]`,
                code: `TMap<FString, int32> HighScores;

// 1. Add or Update
HighScores.Add(TEXT("John"), 5000);

// 2. Finding a value
int32* Score = HighScores.Find(TEXT("John"));
if (Score) {
    int32 FinalVal = *Score;
}

// 3. Removing
HighScores.Remove(TEXT("John"));`,
                explanation: `
                    <h3>Fast Lookups</h3>
                    <p>A <code>TMap</code> (Dictionary) stores data in Key-Value pairs. It is optimized for finding a specific "Value" by looking up a unique "Key".</p>
                    
                    <h4>Lookup Speed</h4>
                    <p>Searching a <code>TArray</code> for a specific name requires looking at every item (O(n)). Searching a <code>TMap</code> is nearly instantaneous regardless of how many items are inside (O(1)).</p>
                    
                    <h4>Note on Pointers</h4>
                    <p>The <code>Find()</code> function returns a pointer to the value. If the key doesn't exist, it returns <code>nullptr</code>. Always check this pointer before trying to use the value!</p>
                `,
                concepts: ["Hash Tables", "O(1) Search", "Associative Containers"],
                practices: ["Use for IDs, inventories, or settings", "Keys must be unique", "Avoid iterating over maps frequently"]
            },
            {
                id: 64,
                title: "UDataTable::FindRow",
                category: "cat-data",
                catName: "Data",
                graph: `flowchart LR
                    CSV[Excel/CSV File] --> DT[DataTable Asset]
                    DT --"FName RowID"--> Find[FindRow]
                    Find --> Struct[C++ Struct Data]`,
                code: `// .h
UPROPERTY(EditAnywhere, Category = "Data")
TObjectPtr<UDataTable> WeaponTable;

// .cpp
FWeaponDataRow* Data = WeaponTable->FindRow<FWeaponDataRow>(
    FName("Sword_01"), 
    TEXT("Weapon Context")
);

if (Data)
{
    float Damage = Data->BaseDamage;
    UStaticMesh* Mesh = Data->WeaponMesh;
}`,
                explanation: `
                    <h3>Data-Driven Design</h3>
                    <p>DataTables allow you to move your game balance (speeds, damage, health) out of the code and into a spreadsheet-like Editor tool. This is essential for large projects where designers need to tweak values constantly.</p>
                    
                    <h4>The Workflow</h4>
                    <ol>
                        <li>Create a <code>USTRUCT</code> that inherits from <code>FTableRowBase</code>.</li>
                        <li>Create a DataTable asset in the Editor based on that struct.</li>
                        <li>Fill it with rows.</li>
                        <li>Fetch the rows in C++ using <code>FindRow</code>.</li>
                    </ol>
                    
                    <h4>Live Updates</h4>
                    <p>You can re-import CSV files while the game is running, allowing for extremely fast iteration cycles.</p>
                `,
                concepts: ["Spreadsheet Integration", "FTableRowBase", "Content Scaling"],
                practices: ["Always inherit from FTableRowBase", "Use FName for row IDs", "Check if row exists (null check)"]
            },
            {
                id: 65,
                title: "UPrimaryDataAsset",
                category: "cat-data",
                catName: "Data",
                graph: `flowchart TD
                    DA[Data Asset] --> Prop1[Icon]
                    DA --> Prop2[Description]
                    DA --> Prop3[ManaCost]
                    DA --"Assigned to"--> Ability[Gameplay Ability]`,
                code: `// .h
UCLASS(BlueprintType)
class UItemDataAsset : public UPrimaryDataAsset
{
    GENERATED_BODY()
public:
    UPROPERTY(EditAnywhere, BlueprintReadOnly)
    FText ItemName;

    UPROPERTY(EditAnywhere, BlueprintReadOnly)
    TObjectPtr<UTexture2D> Icon;
};`,
                explanation: `
                    <h3>Custom Asset Types</h3>
                    <p>While DataTables are great for lists of similar things, <code>UPrimaryDataAsset</code> is better for unique, complex objects like a "Fireball Spell" or a "Quest Definition".</p>
                    
                    <h4>Asset Manager Integration</h4>
                    <p>Primary Data Assets are recognized by Unreal's <strong>Asset Manager</strong>. This allows the engine to track them, load them asynchronously, and bundle them for shipping automatically.</p>
                    
                    <h4>Vs DataTables</h4>
                    <p>DataAssets are easier to use when items have varying properties or need to reference many different assets (like sounds and particles) that would look messy in a spreadsheet row.</p>
                `,
                concepts: ["Custom Assets", "Asset Manager", "Modular Data"],
                practices: ["Use for Spells, Quests, and Item types", "Create an Asset Action for better Editor UX", "Prefer over large nested structs"]
            },
            {
                id: 66,
                title: "FString vs FName vs FText",
                category: "cat-data",
                catName: "Data",
                graph: `flowchart TD
                    S[FString] --"Mutable"--> Edit[Manipulation/Search]
                    N[FName] --"Hashing"--> ID[Fast Comparison/Keys]
                    T[FText] --"Localized"--> UI[User Interface/Display]`,
                code: `// 1. FString - The Workhorse
FString MyStr = "Hello";
MyStr += " World";
MyStr.ToLowerInline();

// 2. FName - The Identity
FName SocketName = "Hand_R"; // Fast comparison

// 3. FText - The Presenter
FText DisplayName = NSLOCTEXT("UI", "HealthLabel", "Health");`,
                explanation: `
                    <h3>The Trinity of Strings</h3>
                    <p>Unreal Engine uses three different types for text data, each optimized for a specific job. Choosing the wrong one can lead to performance issues or UI bugs.</p>
                    
                    <h4>The Breakdown</h4>
                    <ul>
                        <li><strong>FString:</strong> The only one that allows manipulation (cutting, joining, searching). It's the "heaviest" type.</li>
                        <li><strong>FName:</strong> Case-insensitive and extremely fast to compare. It stores a "Hash" of the string. Perfect for IDs, Tags, and Bone names.</li>
                        <li><strong>FText:</strong> Used for everything the player sees. It supports <strong>Localization</strong> (translation) and formatting. Never use FString for UI text!</li>
                    </ul>
                `,
                concepts: ["Localization", "String Hashing", "Memory Allocation"],
                practices: ["Use FName for Keys/IDs", "Use FText for UI", "Use FString only for internal manipulation"]
            },

            // --- VIII. FRAMEWORK & LOGIC ---
            {
                id: 71,
                title: "GetGameInstance Subsystems",
                category: "cat-framework",
                catName: "Framework",
                graph: `flowchart TD
                    GI[Game Instance] --> Sub[C++ Subsystem]
                    Sub --> State[Global Save Data]
                    Sub --> Net[Network Manager]
                    Logic[Any Actor] --"GetSubsystem"--> Sub`,
                code: `// Fetching a subsystem from any actor
UMyGlobalSubsystem* MySub = GetGameInstance()->GetSubsystem<UMyGlobalSubsystem>();

if (MySub)
{
    MySub->GlobalScore += 100;
    MySub->TriggerGlobalEvent();
}`,
                explanation: `
                    <h3>Modern Global Logic</h3>
                    <p>In older versions of Unreal, everyone put their global logic in the <code>GameInstance</code> or <code>GameMode</code>, leading to giant, messy files. <strong>Subsystems</strong> solve this by providing modular, self-contained global objects.</p>
                    
                    <h4>Lifecycles</h4>
                    <ul>
                        <li><strong>GameInstanceSubsystem:</strong> Lives as long as the game is open. Perfect for Save Systems or Settings.</li>
                        <li><strong>WorldSubsystem:</strong> Lives as long as the level is loaded. Perfect for Level Managers or Scoreboards.</li>
                    </ul>
                    
                    <h4>Automatic Initialization</h4>
                    <p>You don't need to "Create" a subsystem. If you define the class in C++, the engine creates it automatically and makes it available everywhere.</p>
                `,
                concepts: ["Modular Architecture", "Global Singletons", "Engine Lifecycles"],
                practices: ["Use for cross-actor communication", "Avoid 'Manager' actors in the level", "Use for Save/Load logic"]
            },
            {
                id: 72,
                title: "HasAuthority() (Networking)",
                category: "cat-framework",
                catName: "Framework",
                graph: `flowchart LR
                    Check{HasAuthority?}
                    Check --"Yes"--> Server[Server: Deal Damage/Save]
                    Check --"No"--> Client[Client: Play VFX/Sound]`,
                code: `void AMyWeapon::Fire()
{
    if (HasAuthority())
    {
        // I am the Server. I actually deal the damage.
        ApplyDamageToTarget();
    }
    else
    {
        // I am a Client. I just play the muzzle flash.
        PlayMuzzleFX();
    }
}`,
                explanation: `
                    <h3>Multiplayer Security</h3>
                    <p><code>HasAuthority()</code> tells you if the current code is running on the "Source of Truth" (the Server) or on a "Remote Proxy" (the Player's Computer).</p>
                    
                    <h4>The Golden Rule</h4>
                    <p>Critical gameplay logic (Health, Score, Inventory, Spawning) <strong>MUST</strong> happen on the Server. If a client tries to change their own health, it's called "Cheating" and the server will simply ignore it.</p>
                    
                    <h4>Visuals vs Logic</h4>
                    <p>Clients are responsible for "Visuals" (FX, Sounds, UI). The Server is responsible for "Math". This separation keeps the game synchronized and fair.</p>
                `,
                concepts: ["Client/Server Model", "Authoritative Logic", "Anti-Cheat"],
                practices: ["Only spawn actors on Authority", "Only modify stats on Authority", "Clients should only handle Cosmetic feedback"]
            },
            {
                id: 73,
                title: "IsLocallyControlled()",
                category: "cat-framework",
                catName: "Framework",
                graph: `flowchart LR
                    P1[Player 1] --"Is Me?"--> Yes[Show HUD]
                    P2[Other Player] --"Is Me?"--> No[Hide HUD]`,
                code: `void AMyCharacter::BeginPlay()
{
    Super::BeginPlay();

    if (IsLocallyControlled())
    {
        // This character is being played by the person
        // sitting at this keyboard. Create their HUD.
        CreatePlayerHUD();
    }
}`,
                explanation: `
                    <h3>Local vs Proxy</h3>
                    <p>In a multiplayer game, you might see 4 characters on your screen. But only <strong>one</strong> of them is "You". <code>IsLocallyControlled()</code> helps you distinguish between your character and the other players.</p>
                    
                    <h4>Use Cases</h4>
                    <ul>
                        <li><strong>UI:</strong> You only want to see your own Health Bar and Mini-map.</li>
                        <li><strong>Input:</strong> You only want your keyboard to move your character, not everyone else's.</li>
                        <li><strong>Camera:</strong> The camera should only follow the locally controlled character.</li>
                    </ul>
                `,
                concepts: ["Possession", "Local User Context", "Multiplayer UI"],
                practices: ["Use for HUD creation", "Use for input binding", "Essential for split-screen and online play"]
            },
            {
                id: 74,
                title: "APlayerController Access",
                category: "cat-framework",
                catName: "Framework",
                graph: `flowchart LR
                    Human[Human Player] --> PC[Player Controller]
                    PC --> Pawn[Character Body]
                    PC --> UI[HUD/Menus]`,
                code: `// Get the controller from an actor
APlayerController* PC = Cast<APlayerController>(GetController());

if (PC)
{
    // Show the mouse cursor for menus
    PC->bShowMouseCursor = true;
    
    // Set input mode to UI only
    FInputModeUIOnly Mode;
    PC->SetInputMode(Mode);
}`,
                explanation: `
                    <h3>The Player's Will</h3>
                    <p>The <code>PlayerController</code> is the interface between the human player and the game. While the <code>Pawn</code> is the physical body that can be killed or swapped, the <code>PlayerController</code> persists and represents the player's presence in the world.</p>
                    
                    <h4>Responsibilities</h4>
                    <ul>
                        <li><strong>Input:</strong> Handling mouse, keyboard, and gamepad.</li>
                        <li><strong>Camera:</strong> Managing the view and field of vision.</li>
                        <li><strong>UI:</strong> Creating and managing the HUD and Pause menus.</li>
                    </ul>
                `,
                concepts: ["Human-Computer Interface", "Actor Possession", "Persistence"],
                practices: ["Store UI refs in the PC", "Handle menus in the PC", "Check for IsLocalController() before using"]
            },
            {
                id: 75,
                title: "Enhanced Input (BindAction)",
                category: "cat-framework",
                catName: "Framework",
                graph: `flowchart LR
                    Key[Space Bar] --> IMC[Mapping Context]
                    IMC --> IA[Input Action: 'Jump']
                    IA --> Trigger[C++ Function]`,
                code: `// .h
UPROPERTY(EditAnywhere, Category="Input")
TObjectPtr<UInputAction> JumpAction;

// .cpp - Setup
void AMyChar::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
    UEnhancedInputComponent* EIP = Cast<UEnhancedInputComponent>(PlayerInputComponent);
    if (EIP)
    {
        EIP->BindAction(JumpAction, ETriggerEvent::Started, this, &AMyChar::Jump);
    }
}`,
                explanation: `
                    <h3>Next-Gen Input</h3>
                    <p>Enhanced Input is the UE5 standard for handling player controls. It is much more flexible than the old "Action Mappings" because it allows for runtime remapping, complex triggers (hold, tap, chord), and "Input Mapping Contexts".</p>
                    
                    <h4>Mapping Contexts</h4>
                    <p>You can swap contexts on the fly. For example, when the player enters a vehicle, you can remove the "Walking" context and add the "Driving" context, automatically changing what the buttons do.</p>
                `,
                concepts: ["Input Actions", "Mapping Contexts", "Input Modifiers"],
                practices: ["Use for all new projects", "Provide default assets in C++", "Check ETriggerEvent types (Started for one-off actions)"]
            },

            // --- IX. UI & DEBUG ---
            {
                id: 81,
                title: "UE_LOG (Debugging)",
                category: "cat-ui",
                catName: "Debug",
                graph: `flowchart LR
                    Code[Code Execution] --> Log[UE_LOG Macro]
                    Log --"Verbosity"--> Out[Output Log Window]
                    Log --"Format"--> Msg[Formatted String]`,
                code: `// 1. Simple text log
UE_LOG(LogTemp, Log, TEXT("Hello Unreal!"));

// 2. Warning with variables
float MyHP = 75.5f;
UE_LOG(LogTemp, Warning, TEXT("Current HP: %f"), MyHP);

// 3. Error (Highlights in Red)
UE_LOG(LogTemp, Error, TEXT("CRITICAL: Component %s is null!"), *GetName());`,
                explanation: `
                    <h3>Talking to the Console</h3>
                    <p><code>UE_LOG</code> is the primary tool for debugging C++ in Unreal. It prints messages to the <strong>Output Log</strong> window, allowing you to track variables and logic flow without stopping the game.</p>
                    
                    <h4>Verbosity Levels</h4>
                    <ul>
                        <li><strong>Log:</strong> Grey text. General information.</li>
                        <li><strong>Warning:</strong> Yellow text. Something is unusual but not game-breaking.</li>
                        <li><strong>Error:</strong> Red text. Something has gone wrong and needs immediate attention.</li>
                    </ul>
                    
                    <h4>Formatting</h4>
                    <p>It uses standard printf-style formatting. Note that for <code>FString</code>, you must use the <code>*</code> operator (e.g., <code>*MyString</code>) to convert it to a TCHAR pointer which the macro expects.</p>
                `,
                concepts: ["Log Categories", "Printf Formatting", "Verbosity Levels"],
                practices: ["Don't leave 'Log' verbosity in ship builds", "Use 'LogTemp' for quick tests", "Create custom log categories for larger projects"]
            },
            {
                id: 82,
                title: "DrawDebugLine",
                category: "cat-ui",
                catName: "Debug",
                graph: `flowchart LR
                    Start[Start Point] --"Draw"--> End[End Point]
                    End --"Life: 5s"--> Fade[Line Disappears]`,
                code: `FVector Start = GetActorLocation();
FVector End = Start + (GetActorForwardVector() * 500.f);

// Draw a green line that lasts for 2 seconds
DrawDebugLine(
    GetWorld(), 
    Start, 
    End, 
    FColor::Green, 
    false, // Persistent?
    2.0f,  // LifeTime
    0,     // Depth Priority
    2.0f   // Thickness
);`,
                explanation: `
                    <h3>Visualizing the Invisible</h3>
                    <p>Debugging physics or math in your head is hard. <code>DrawDebugLine</code> (and its siblings like <code>DrawDebugSphere</code> and <code>DrawDebugBox</code>) allows you to draw shapes directly in the 3D game world.</p>
                    
                    <h4>Use Cases</h4>
                    <ul>
                        <li><strong>Line Traces:</strong> See exactly where your "bullets" are shooting.</li>
                        <li><strong>AI Paths:</strong> Visualize where an NPC is planning to walk.</li>
                        <li><strong>Vectors:</strong> Draw the 'Forward' or 'Up' vectors to debug rotation issues.</li>
                    </ul>
                    
                    <h4>Optimization</h4>
                    <p>Never leave debug drawing code in your final game! Always wrap these calls in a <code>#if WITH_EDITOR</code> block or use them only for temporary debugging.</p>
                `,
                concepts: ["3D Visualization", "Physics Debugging", "Development Tools"],
                practices: ["Use different colors for different states", "Set a short LifeTime to avoid clutter", "Use for Raycast visualization"]
            },
            {
                id: 83,
                title: "NativeConstruct (UI Start)",
                category: "cat-ui",
                catName: "UI",
                graph: `flowchart TD
                    Create[CreateWidget] --> Init[Initialize]
                    Init --> NC[NativeConstruct]
                    NC --> Bind[Bind C++ Buttons/Logic]
                    Bind --> View[Show on Screen]`,
                code: `// .h
virtual void NativeConstruct() override;

// .cpp
void UMyWidget::NativeConstruct()
{
    // 1. ALWAYS call Super first
    Super::NativeConstruct();

    // 2. Initialize UI data
    if (AttackButton)
    {
        AttackButton->OnClicked.AddDynamic(this, &UMyWidget::OnAttackClicked);
    }
}`,
                explanation: `
                    <h3>The BeginPlay of UI</h3>
                    <p><code>NativeConstruct</code> is the C++ equivalent of the "Construct" event in Widget Blueprints. It is called when the widget is created and ready to be used.</p>
                    
                    <h4>Binding Delegates</h4>
                    <p>This is the perfect place to bind your <code>BindWidget</code> components to C++ functions. For example, connecting a button's <code>OnClicked</code> event to a specific method in your class.</p>
                    
                    <h4>Timing</h4>
                    <p>Avoid doing heavy logic in the widget constructor. Wait until <code>NativeConstruct</code> to ensure that all sub-widgets (buttons, text blocks) have been fully initialized by the engine.</p>
                `,
                concepts: ["UMG Lifecycle", "UI Event Binding", "Widget Initialization"],
                practices: ["Always call Super::NativeConstruct", "Validate BindWidget pointers", "Avoid heavy calculations here"]
            },

            // --- X. C++ MECHANICS ---
            {
                id: 91,
                title: "Cast<T> (Safe Type Casting)",
                category: "cat-cpp",
                catName: "C++",
                graph: `flowchart LR
                    Base[Generic Actor] --"Cast<ACharacter>"--> Check{Success?}
                    Check --"Yes"--> Success[Valid Character Pointer]
                    Check --"No"--> Failure[nullptr]`,
                code: `// Safely check if an actor is a character
ACharacter* MyChar = Cast<ACharacter>(OtherActor);

if (MyChar)
{
    // It is a character! Safe to use character-specific functions.
    MyChar->Jump();
}
else
{
    // It's something else (a prop, a light, etc.)
}`,
                explanation: `
                    <h3>Safe Inheritance Checks</h3>
                    <p>Unreal's <code>Cast&lt;T&gt;</code> is a specialized version of C++ casting that uses the reflection system to safely convert pointers between classes.</p>
                    
                    <h4>Why use Cast?</h4>
                    <p>Standard C++ <code>static_cast</code> can be dangerous; if you cast a Rock into a Player, the game will crash. <code>Cast&lt;T&gt;</code> will simply return <code>nullptr</code> if the conversion isn't valid, allowing you to handle the error gracefully.</p>
                    
                    <h4>Performance</h4>
                    <p>Casting has a small cost. If you're doing it 1,000 times a frame in <code>Tick</code>, consider "Caching" the result in <code>BeginPlay</code> instead.</p>
                `,
                concepts: ["Runtime Type Information (RTTI)", "Inheritance", "Pointer Safety"],
                practices: ["Always check if the result is null", "Cache frequently used casts", "Prefer Cast over static_cast for UObjects"]
            },
            {
                id: 92,
                title: "TObjectPtr (Smart Pointer)",
                category: "cat-cpp",
                catName: "C++",
                graph: `flowchart LR
                    Ptr[TObjectPtr] --"Point to"--> Obj[UObject]
                    Obj --"Destroyed"--> Ptr
                    Ptr --"Internal"--> State[Tracks GC Status]`,
                code: `// UE5 Header Standard (.h)
UPROPERTY(EditAnywhere, Category = "Components")
TObjectPtr<UStaticMeshComponent> MeshPtr;

// Usage in (.cpp) is exactly like a raw pointer:
if (MeshPtr)
{
    MeshPtr->SetVisible(true);
}`,
                explanation: `
                    <h3>The New UE5 Standard</h3>
                    <p>In Unreal Engine 5, <code>TObjectPtr</code> replaced raw pointers (e.g., <code>UStaticMesh*</code>) for class properties. It is a "smart" pointer designed specifically for the reflection system.</p>
                    
                    <h4>Benefits</h4>
                    <p>In editor builds, <code>TObjectPtr</code> provides extra tracking for the Garbage Collector and allows for "Lazy Loading" of properties. In final shipping builds, it automatically converts back into a raw pointer, so there is zero performance penalty.</p>
                    
                    <h4>Where to use?</h4>
                    <p>Use <code>TObjectPtr</code> for any <code>UPROPERTY</code> in your header files. Inside your <code>.cpp</code> functions, you can still use raw pointers for local variables.</p>
                `,
                concepts: ["Pointer Modernization", "Editor Debugging", "Zero-Cost Abstractions"],
                practices: ["Use in Header files for all UObject properties", "Standard for UE5.0 and later", "Works seamlessly with UPROPERTY()"]
            },
            {
                id: 93,
                title: "TWeakObjectPtr",
                category: "cat-cpp",
                catName: "C++",
                graph: `flowchart LR
                    Weak[Weak Pointer] --"Watch"--> Target[Actor]
                    Target --"GC / Destroy"--> Weak
                    Weak --"IsValid"--> State{Is Target Still Alive?}
                    State --"No"--> Null[nullptr]`,
                code: `// Store a reference to an enemy without 'owning' it
TWeakObjectPtr<AActor> CurrentTarget;

void AMyActor::SetTarget(AActor* NewTarget) {
    CurrentTarget = NewTarget;
}

void AMyActor::AttackTarget() {
    if (CurrentTarget.IsValid()) {
        // Target still exists!
        DoDamage(CurrentTarget.Get());
    }
}`,
                explanation: `
                    <h3>Preventing Memory Leaks</h3>
                    <p>A "Hard Pointer" (like <code>TObjectPtr</code> or a raw pointer) prevents the Garbage Collector from deleting an object. A <strong>Weak Pointer</strong> does NOT.</p>
                    
                    <h4>The Observer Pattern</h4>
                    <p>Imagine a "Targeting System". If 50 enemies are targeting the Player and use hard pointers, the Player can never be deleted from memory! By using <code>TWeakObjectPtr</code>, the enemies can "watch" the player, but if the player is destroyed, the pointers automatically become null.</p>
                    
                    <h4>Usage</h4>
                    <p>Always use <code>.IsValid()</code> before calling <code>.Get()</code> to ensure the object hasn't been deleted since the last time you checked.</p>
                `,
                concepts: ["Circular References", "Memory Management", "Validity Checking"],
                practices: ["Use for temporary references (Targets, Interactors)", "Prevents objects from being 'stuck' in memory", "Always check .IsValid()"]
            },
            {
                id: 94,
                title: "UINTERFACE Setup",
                category: "cat-cpp",
                catName: "C++",
                graph: `flowchart TD
                    IFace[IInteractable Interface] --> Door[Actor: Door]
                    IFace --> Chest[Actor: Chest]
                    IFace --> NPC[Actor: NPC]
                    Logic[Player] --"Execute_Interact"--> IFace`,
                code: `// .h - The Blueprint-visible part
UINTERFACE(MinimalAPI)
class UInteractable : public UInterface { GENERATED_BODY() };

// .h - The actual C++ part
class IInteractable {
    GENERATED_BODY()
public:
    UFUNCTION(BlueprintNativeEvent, Category = "Interaction")
    void Interact(AActor* Caller);
};

// Usage:
if (OtherActor->GetClass()->ImplementsInterface(UInteractable::StaticClass())) {
    IInteractable::Execute_Interact(OtherActor, this);
}`,
                explanation: `
                    <h3>The Gameplay Contract</h3>
                    <p>Interfaces allow completely different classes (like a "Door" and an "NPC") to share common functionality (like being "Interactable") without inheriting from the same parent.</p>
                    
                    <h4>C++ & Blueprint Compatibility</h4>
                    <p>Unreal Interfaces are unique because they can be implemented in both C++ and Blueprints. To call an interface function safely, you should use the <code>Execute_</code> prefix (e.g., <code>IInteractable::Execute_Interact</code>).</p>
                    
                    <h4>Why use them?</h4>
                    <p>It keeps your code <strong>Decoupled</strong>. Your Player class doesn't need to know how a "Treasure Chest" works; it just knows the chest implements the "Interactable" interface and calls the function.</p>
                `,
                concepts: ["Decoupling", "Polymorphism", "Cross-Class Communication"],
                practices: ["Use for generic interactions", "Always use the Execute_ wrapper", "Keep interfaces focused on a single task"]
            },
            {
                id: 95,
                title: "Const Correctness",
                category: "cat-cpp",
                catName: "C++",
                graph: `flowchart LR
                    Func[Function] --"const"--> Promise[Promise: 'I won't change data']
                    Promise --> Read[Read-Only Access]
                    Promise --"Prevents"--> Bugs[Accidental Data Modification]`,
                code: `// This function PROMISES not to change any variables
float GetHealth() const 
{ 
    return CurrentHealth; 
}

// C++ will throw an error if you try this:
float ResetHealth() const 
{ 
    CurrentHealth = 100.f; // ERROR! Cannot modify in const func
    return CurrentHealth;
}`,
                explanation: `
                    <h3>Code Safety and Optimization</h3>
                    <p>In C++, adding <code>const</code> to a function tells the compiler (and other programmers) that this function is "Read-Only" and won't modify the state of the object.</p>
                    
                    <h4>Why it matters?</h4>
                    <ul>
                        <li><strong>Bug Prevention:</strong> It prevents you from accidentally changing a value in a function that was only supposed to "get" data.</li>
                        <li><strong>Blueprint Pure:</strong> Functions marked as <code>const</code> in C++ are automatically treated as <strong>BlueprintPure</strong> nodes (no execution pins) when exposed to Blueprints.</li>
                        <li><strong>Performance:</strong> The compiler can perform certain optimizations when it knows data won't change.</li>
                    </ul>
                `,
                concepts: ["Read-only access", "BlueprintPure logic", "Compiler Optimization"],
                practices: ["Mark all 'Getters' as const", "Use const references for large function inputs", "Essential for thread safety"]
            },
            {
                id: 96,
                title: "Virtual vs Override",
                category: "cat-cpp",
                catName: "C++",
                graph: `flowchart TD
                    Base[Base Class: virtual Die] --> Child[Child Class: override Die]
                    Child --> Log[Custom Death Logic]
                    Child --"Super::Die"--> Base[Engine Death Logic]`,
                code: `// --- BaseClass.h ---
virtual void Die();

// --- ChildClass.h ---
virtual void Die() override;

// --- ChildClass.cpp ---
void AChildClass::Die() 
{
    PlayCustomAnimation();
    Super::Die(); // Run the base logic too!
}`,
                explanation: `
                    <h3>Polymorphism in Unreal</h3>
                    <p>These two keywords are the foundation of inheritance. They allow you to define a general behavior in a "Parent" class and then specialize it in a "Child" class.</p>
                    
                    <h4>The Keywords</h4>
                    <ul>
                        <li><strong>Virtual:</strong> Placed in the Parent class. It means "Children are allowed to change how this function works."</li>
                        <li><strong>Override:</strong> Placed in the Child class. It means "I am intentionally changing my parent's function."</li>
                    </ul>
                    
                    <h4>The 'Override' Safety</h4>
                    <p>Always use the <code>override</code> keyword. If you make a typo (e.g., <code>Dye()</code> instead of <code>Die()</code>), the compiler will catch it and warn you, preventing a bug where your custom logic never runs.</p>
                `,
                concepts: ["Inheritance", "Function Shadowing", "Virtual Method Tables (VMT)"],
                practices: ["Always use 'override' keyword", "Use 'virtual' for anything a child might want to change", "Don't forget the Super:: call"]
            },
            {
                id: 97,
                title: "check() / ensure()",
                category: "cat-cpp",
                catName: "C++",
                graph: `flowchart TD
                    Check[check: Fatal] --"Failure"--> Crash[Game Crashes]
                    Ensure[ensure: Warning] --"Failure"--> Log[Print Error & Continue]`,
                code: `// 1. check: Use for things that MUST be true
// If Mesh is null, the game crashes immediately.
check(Mesh != nullptr);

// 2. ensure: Use for things that SHOULD be true
// If Level is 0, it prints a big error but keeps running.
if (ensure(CurrentLevel > 0)) {
    CalculateXP();
}`,
                explanation: `
                    <h3>Professional Error Handling</h3>
                    <p>Unreal provides several "Assert" macros to help you catch bugs early in development. They act as internal documentation for what your code expects.</p>
                    
                    <h4>check()</h4>
                    <p>A "Hard Assert". If the condition is false, the game <strong>Crashes</strong>. Use this for critical failures that would cause a corrupted save or a worse crash later (like a missing vital component).</p>
                    
                    <h4>ensure()</h4>
                    <p>A "Soft Assert". If the condition is false, the game <strong>Freezes</strong> for a second, prints a callstack to the log, but then lets you keep playing. This is much better for daily development as it doesn't interrupt your workflow.</p>
                `,
                concepts: ["Assertions", "Defensive Programming", "Error Propagation"],
                practices: ["Use 'check' for pointers that cannot be null", "Use 'ensure' for non-fatal logic errors", "Asserts are stripped from final builds (no performance cost)"]
            },
            {
                id: 98,
                title: "IsA() Type Checking",
                category: "cat-cpp",
                catName: "C++",
                graph: `flowchart LR
                    Obj[Object Instance] --"IsA?"--> Class[ACharacter]
                    Class --"Yes"--> Result[Returns True]
                    Class --"No"--> Result2[Returns False]`,
                code: `// A fast check without needing a variable
if (OtherActor->IsA(ACharacter::StaticClass()))
{
    // We know it's a character, even without casting!
    UE_LOG(LogTemp, Log, TEXT("Watch out, a character!"));
}`,
                explanation: `
                    <h3>Quick Class Validation</h3>
                    <p><code>IsA()</code> is a high-performance function used to check if an object belongs to a specific class or inherits from it. It's the faster, "lighter" version of <code>Cast&lt;T&gt;</code>.</p>
                    
                    <h4>IsA vs Cast</h4>
                    <p>Use <code>Cast&lt;T&gt;</code> when you actually need to <strong>call a function</strong> on that class. Use <code>IsA()</code> when you just need to <strong>know</strong> what type it is (e.g., "Is this thing a projectile? If so, ignore it").</p>
                    
                    <h4>Under the Hood</h4>
                    <p><code>IsA</code> simply looks at the object's class metadata. It doesn't perform the memory-safety checks that <code>Cast</code> does, making it the preferred choice for simple identification logic.</p>
                `,
                concepts: ["Class Hierarchy", "Type Identification", "Reflection Performance"],
                practices: ["Use for simple branch logic", "Faster than casting", "Works with Interfaces too"]
            },

            // --- Additional Mix ---
            {
                id: 110,
                title: "GetWorld() Entry Point",
                category: "cat-lifecycle",
                catName: "World",
                graph: `flowchart LR
                    Actor[Actor Instance] --"GetWorld()"--> World[UWorld Object]
                    World --> Physics[LineTrace/Physics]
                    World --> Timers[Timer Manager]
                    World --> Spawning[SpawnActor]`,
                code: `// Safely accessing the world
UWorld* World = GetWorld();

if (World)
{
    // Now you can use world-level features
    World->GetTimerManager().SetTimer(...);
    
    // Check if we are in the Editor or Gameplay
    if (World->IsGameWorld()) { ... }
}`,
                explanation: `
                    <h3>The World Context</h3>
                    <p><code>GetWorld()</code> is the gateway to almost every high-level engine feature. If an Actor doesn't have a valid world, it basically doesn't exist in the game simulation.</p>
                    
                    <h4>Why it returns null?</h4>
                    <p>In the constructor, <code>GetWorld()</code> often returns <code>nullptr</code> because the actor hasn't been placed in a level yet. Always wait until <code>BeginPlay</code> to use world-dependent logic.</p>
                `,
                concepts: ["World Context", "Singleton Access", "Execution Environment"],
                practices: ["Always check for null", "Avoid using in constructors", "Use for Spawning and Timers"]
            },
            {
                id: 111,
                title: "StaticLoadObject (Sync)",
                category: "cat-data",
                catName: "Data",
                graph: `flowchart LR
                    Path[Path: '/Game/Textures/T_UI'] --"StaticLoadObject"--> RAM[Immediate RAM Load]
                    RAM --> Ptr[Valid Object Pointer]`,
                code: `// Force-load a texture from the hard drive
UTexture2D* MyIcon = Cast<UTexture2D>(StaticLoadObject(
    UTexture2D::StaticClass(), 
    nullptr, 
    TEXT("/Game/UI/Textures/Icon_Sword")
));

if (MyIcon) {
    SetIcon(MyIcon);
}`,
                explanation: `
                    <h3>Forced Loading</h3>
                    <p>While <code>TSoftObjectPtr</code> is the preferred way to load things, <code>StaticLoadObject</code> is the "Hammer" that forces an asset to load from the disk right now.</p>
                    
                    <h4>The Cost of Speed</h4>
                    <p>Loading assets from disk is slow. If you call this during gameplay, the screen will likely freeze (hitch) for a few milliseconds while the file is read. Only use this for small assets or during loading screens.</p>
                `,
                concepts: ["Synchronous I/O", "Asset Referencing", "Manual Memory Loading"],
                practices: ["Avoid in Tick", "Use for small UI icons", "Prefer Soft Pointers for large meshes"]
            },
            {
                id: 112,
                title: "FMath::MapRangeClamped",
                category: "cat-math",
                catName: "Math",
                graph: `flowchart LR
                    In[In: 0 to 1000] --"Map To"--> Out[Out: 1.0 to 2.0]
                    Val[Current: 500] --"Result"--> Res[1.5]`,
                code: `// Turn 'Current Speed' into 'Engine Pitch'
// Speed 0-1000 -> Pitch 1.0-2.0
float CurrentSpeed = GetVelocity().Size();
float EnginePitch = FMath::MapRangeClamped(
    CurrentSpeed, 
    0.f, 1000.f, // Input Range
    1.0f, 2.0f   // Output Range
);`,
                explanation: `
                    <h3>Value Mapping</h3>
                    <p>This is arguably the most useful math function in Unreal. it takes a value from one range and "stretches" it to fit into another range.</p>
                    
                    <h4>Why Clamped?</h4>
                    <p>The "Clamped" part ensures that if your input goes outside the range (e.g., speed is 1200), the output stays at the max (2.0) instead of continuing to grow.</p>
                `,
                concepts: ["Linear Interpolation", "Normalization", "Range Remapping"],
                practices: ["Essential for Audio pitching", "Use for UI health bars", "Perfect for mapping input to sensitivity"]
            },
            {
                id: 113,
                title: "AttachToComponent",
                category: "cat-comp",
                catName: "Components",
                graph: `flowchart LR
                    Weapon[Actor: Sword] --"Attach"--> Hand[Component: Mesh]
                    Hand --"SnapToTarget"--> Weapon`,
                code: `// Picking up a weapon at runtime
FAttachmentTransformRules Rules(
    EAttachmentRule::SnapToTarget, // Location
    EAttachmentRule::SnapToTarget, // Rotation
    EAttachmentRule::KeepWorld,    // Scale
    true                           // Weld Simulated Bodies
);

MyWeapon->AttachToComponent(GetMesh(), Rules, TEXT("Hand_R_Socket"));`,
                explanation: `
                    <h3>Runtime Parenting</h3>
                    <p>Unlike <code>SetupAttachment</code>, which is for constructors, <code>AttachToComponent</code> is used during active gameplay to glue actors or components together.</p>
                    
                    <h4>Attachment Rules</h4>
                    <ul>
                        <li><strong>SnapToTarget:</strong> Teleports the item exactly to the parent's location.</li>
                        <li><strong>KeepRelative:</strong> Keeps the current offset.</li>
                        <li><strong>KeepWorld:</strong> Stays exactly where it is in the world but follows the parent's movement.</li>
                    </ul>
                `,
                concepts: ["Dynamic Hierarchy", "Sockets", "Attachment Rules"],
                practices: ["Use for weapons and mounts", "Check 'Weld Simulated Bodies' for physics", "Always use a valid Socket name"]
            },
            {
                id: 114,
                title: "FCollisionQueryParams",
                category: "cat-phys",
                catName: "Physics",
                graph: `flowchart TD
                    Trace[Line Trace] --> Params[Query Params]
                    Params --> Ignored[Ignore List: Self, Owner]
                    Params --> Detail[Trace Complex: True]
                    Params --> Tags[Trace Tag: 'Bullet']`,
                code: `FCollisionQueryParams Params;

// 1. Don't hit the person firing the gun
Params.AddIgnoredActor(this);
Params.AddIgnoredActor(GetOwner());

// 2. Use per-polygon collision (Accurate but slow)
Params.bTraceComplex = true;

// 3. Return physical material (Wood, Metal, etc)
Params.bReturnPhysicalMaterial = true;`,
                explanation: `
                    <h3>Filtering Physics Queries</h3>
                    <p>When you perform a Trace or a Sweep, the <code>FCollisionQueryParams</code> struct tells the engine exactly how to behave and what to ignore.</p>
                    
                    <h4>Trace Complex</h4>
                    <p>By default, traces use "Simple" collision (boxes/spheres). If <code>bTraceComplex</code> is true, it checks against the actual triangles of the mesh. This is necessary for "Headshot" detection but much more expensive.</p>
                `,
                concepts: ["Query Optimization", "Physics Filtering", "Collision Resolution"],
                practices: ["Always ignore 'this'", "Use Simple collision for most logic", "Use TraceComplex for precise bullet hits"]
            }
        ];

        const additionalPieces = [
             {
                id: 201,
                title: "UAnimInstance C++ Base",
                category: "cat-anim",
                catName: "Animation",
                graph: `flowchart TD
                    Mesh[Skeletal Mesh] --> ABP[Anim Blueprint]
                    ABP --"Inherits"--> CBase[C++ AnimInstance]
                    CBase --"NativeUpdate"--> Vars[Update Speed/Pitch/Yaw]
                    Vars --> Graph[AnimGraph Transitions]`,
                code: `// --- MyAnimInstance.h ---
UCLASS()
class UMyAnimInstance : public UAnimInstance {
    GENERATED_BODY()
public:
    virtual void NativeUpdateAnimation(float DeltaSeconds) override;

    UPROPERTY(BlueprintReadOnly, Category="Movement")
    float GroundSpeed;
};

// --- MyAnimInstance.cpp ---
void UMyAnimInstance::NativeUpdateAnimation(float DeltaSeconds) {
    Super::NativeUpdateAnimation(DeltaSeconds);
    if (APawn* Pawn = TryGetPawnOwner()) {
        GroundSpeed = Pawn->GetVelocity().Size();
    }
}`,
                explanation: `
                    <h3>Driving Animation with C++</h3>
                    <p>While the <code>AnimGraph</code> is great for visual blending, the logic that drives those transitions (calculating speed, falling state, combat mode) should live in a C++ base class for performance and organization.</p>
                    
                    <h4>Native Hooks</h4>
                    <ul>
                        <li><strong>NativeInitializeAnimation:</strong> The "BeginPlay" for animations. Good for caching pointers to the Character or Movement Component.</li>
                        <li><strong>NativeUpdateAnimation:</strong> The "Tick" for animations. Use this to update variables that the AnimGraph uses to switch between states.</li>
                    </ul>
                `,
                concepts: ["AnimInstance Lifecycle", "Data-Driven Animation", "Performance Optimization"],
                practices: ["Cache the Pawn pointer", "Keep logic in C++, visuals in BP", "Avoid complex math in the Update tick"]
            },
            {
                id: 202,
                title: "Montage_Play & Delegates",
                category: "cat-anim",
                catName: "Animation",
                graph: `flowchart LR
                    Logic[Attack Input] --> Play[Montage_Play]
                    Play --> Wait{Wait for End}
                    Wait --"OnCompleted"--> Reset[Reset State]
                    Wait --"OnInterrupted"--> Fail[Handle Stun/Cancel]`,
                code: `// Triggering an attack montage and reacting to its end
void AMyCharacter::PerformAttack() {
    UAnimInstance* AnimInst = GetMesh()->GetAnimInstance();
    if (AnimInst && AttackMontage) {
        AnimInst->Montage_Play(AttackMontage);

        FOnMontageEnded EndDelegate;
        EndDelegate.BindUObject(this, &AMyCharacter::OnAttackFinished);
        AnimInst->Montage_SetEndDelegate(EndDelegate, AttackMontage);
    }
}

void AMyCharacter::OnAttackFinished(UAnimMontage* Montage, bool bInterrupted) {
    bIsAttacking = false;
}`,
                explanation: `
                    <h3>Orchestrating Actions</h3>
                    <p>Montages allow you to play specific animations (like an attack or a reload) on top of your character's state machine. Using <strong>Delegates</strong> allows your gameplay code to know exactly when the animation finishes.</p>
                    
                    <h4>Handling Interruptions</h4>
                    <p>The <code>bInterrupted</code> boolean is critical. If your player gets hit and stunned while attacking, the montage will be interrupted. Your code needs to know this to properly reset state or stop SFX.</p>
                `,
                concepts: ["Animation Montages", "Dynamic Delegates", "State Synchronization"],
                practices: ["Always handle bInterrupted", "Don't hardcode duration, use the delegate", "Check if AnimInstance is valid"]
            },
            {
                id: 203,
                title: "UAIPerceptionComponent",
                category: "cat-ai",
                catName: "AI",
                graph: `flowchart TD
                    Perc[Perception Component] --> Sight[Sight Sense]
                    Perc --> Hear[Hearing Sense]
                    Sight --"Detected"--> Event[OnTargetPerceptionUpdated]
                    Event --> BlackB[Update Blackboard]`,
                code: `// --- MyAIController.h ---
UPROPERTY(VisibleAnywhere)
TObjectPtr<UAIPerceptionComponent> PerceptionComp;

TObjectPtr<UAISenseConfig_Sight> SightConfig;

// --- MyAIController.cpp ---
AMyAIController::AMyAIController() {
    PerceptionComp = CreateDefaultSubobject<UAIPerceptionComponent>(TEXT("PerceptionComp"));
    SightConfig = CreateDefaultSubobject<UAISenseConfig_Sight>(TEXT("SightConfig"));
    
    SightConfig->SightRadius = 2000.f;
    SightConfig->LoseSightRadius = 2500.f;
    SightConfig->PeripheralVisionAngleDegrees = 90.f;
    
    PerceptionComp->ConfigureSense(*SightConfig);
    PerceptionComp->SetDominantSense(SightConfig->GetSenseImplementation());
}`,
                explanation: `
                    <h3>AI Senses</h3>
                    <p>The AIPerception system is the modern way NPCs "see" and "hear" the world. It is much more efficient than doing manual line traces from the AI's eyes every frame.</p>
                    
                    <h4>How it works</h4>
                    <p>The component manages various "Senses". When a "Stimulus" (like a player walking into view) is detected, it triggers the <code>OnTargetPerceptionUpdated</code> delegate. This allows your AI to react only when something actually changes.</p>
                `,
                concepts: ["AI Senses", "Stimulus Handling", "NPC Awareness"],
                practices: ["Set a Dominant Sense", "Use TObjectPtr for components and sense configs", "Use LoseSightRadius for 'chase' behavior", "Configure collision channels for sight"]
            },
            {
                id: 204,
                title: "UBTTaskNode (Custom Task)",
                category: "cat-ai",
                catName: "AI",
                graph: `flowchart LR
                    BT[Behavior Tree] --"Execute"--> Task[C++ Task]
                    Task --"Success"--> BT
                    Task --"Failure"--> BT`,
                code: `// --- BTTask_FindLocation.h ---
UCLASS()
class UBTTask_FindLocation : public UBTTaskNode {
    GENERATED_BODY()
    virtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory) override;
};

// --- BTTask_FindLocation.cpp ---
EBTNodeResult::Type UBTTask_FindLocation::ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory) {
    AAIController* AIController = OwnerComp.GetAIOwner();
    APawn* AIPawn = AIController->GetPawn();
    
    FVector RandomLoc = UNavigationSystemV1::GetRandomReachablePointInRadius(GetWorld(), AIPawn->GetActorLocation(), 1000.f);
    
    OwnerComp.GetBlackboardComponent()->SetValueAsVector(FName("TargetLoc"), RandomLoc);
    return EBTNodeResult::Succeeded;
}`,
                explanation: `
                    <h3>Behavior Tree Extensions</h3>
                    <p>While Behavior Trees are usually edited visually, the actual logic for complex tasks (like finding a tactical position or pathfinding) is best written in C++ for speed and reusability.</p>
                    
                    <h4>Task Lifecycle</h4>
                    <p>The <code>ExecuteTask</code> function is the entry point. You must return a result: <code>Succeeded</code>, <code>Failed</code>, or <code>InProgress</code> (for tasks that take time, like moving).</p>
                `,
                concepts: ["Behavior Trees", "Blackboard Integration", "Navigation Queries"],
                practices: ["Keep tasks modular", "Use Blackboard Keys for data", "Check for valid Pawn/Controller"]
            },
            {
                id: 210,
                title: "ASC Initialization (GAS)",
                category: "cat-gas",
                catName: "GAS",
                graph: `flowchart TD
                    Actor[Player Character] --"Owns"--> ASC[Ability System Component]
                    ASC --"Init"--> ActorInfo[AbilityActorInfo]
                    ActorInfo --"Pawn"--> Avatar[Avatar Actor]
                    ActorInfo --"Controller"--> Owner[Owner Actor]`,
                code: `// --- MyCharacter.cpp ---
void AMyCharacter::PossessedBy(AController* NewController) {
    Super::PossessedBy(NewController);
    
    // Server-side GAS Init
    if (AbilitySystemComponent) {
        AbilitySystemComponent->InitAbilityActorInfo(this, this);
        InitializeAttributes(); // Custom helper
        AddDefaultAbilities();  // Custom helper
    }
}

void AMyCharacter::OnRep_PlayerState() {
    Super::OnRep_PlayerState();
    
    // Client-side GAS Init
    if (AbilitySystemComponent) {
        AbilitySystemComponent->InitAbilityActorInfo(this, this);
    }
}`,
                explanation: `
                    <h3>The GAS Foundation</h3>
                    <p>The <strong>Ability System Component (ASC)</strong> is the brain of the Gameplay Ability System. Before you can use any abilities or attributes, you must initialize the <code>AbilityActorInfo</code>.</p>
                    
                    <h4>Owner vs Avatar</h4>
                    <p>In most single-player games, the Character is both the <strong>Owner</strong> (the object that holds the data) and the <strong>Avatar</strong> (the physical representation in the world). However, in many professional projects, the ASC lives on the <code>PlayerState</code> so it persists even if the Pawn is destroyed and respawned.</p>
                `,
                concepts: ["Ability System Component", "Owner vs Avatar", "GAS Lifecycle"],
                practices: ["Init on both Server and Client", "Call InitAbilityActorInfo whenever Pawn is possessed", "Keep ASC on PlayerState for persistence"]
            },
            {
                id: 211,
                title: "UAttributeSet Definition",
                category: "cat-gas",
                catName: "GAS",
                graph: `flowchart LR
                    Effect[Gameplay Effect] --"Modifies"--> Attr[Attribute]
                    Attr --"Health"--> UI[Health Bar]
                    Attr --"Stamina"--> Move[Sprinting Logic]`,
                code: `// Use the standard ACCESSORS macro for GAS
#define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \\
	GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \\
	GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \\
	GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \\
	GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)

UCLASS()
class UMyAttributeSet : public UAttributeSet {
    GENERATED_BODY()
public:
    UPROPERTY(BlueprintReadOnly, Category="Attributes")
    FGameplayAttributeData Health;
    ATTRIBUTE_ACCESSORS(UMyAttributeSet, Health)
    
    virtual void PostGameplayEffectExecute(const FGameplayEffectModCallbackData& Data) override;
};`,
                explanation: `
                    <h3>Defining Actor Stats</h3>
                    <p>AttributeSets are where you define the numerical values of your character, such as Health, Mana, or Strength. GAS handles the complex math of "Base Value" vs "Current Value" (after buffs/debuffs) automatically.</p>
                    
                    <h4>PostGameplayEffectExecute</h4>
                    <p>This is the most important function in an AttributeSet. It is called after an effect (like damage or healing) has been applied. This is where you "Clamp" the health so it doesn't go below zero or above the max.</p>
                `,
                concepts: ["Gameplay Attributes", "Data Clamping", "Stat Management"],
                practices: ["Use the ATTRIBUTE_ACCESSORS macro", "Only define numerical stats", "Clamp values in PostGameplayEffectExecute"]
            },
            {
                id: 212,
                title: "UGameInstanceSubsystem",
                category: "cat-subsystems",
                catName: "Subsystems",
                graph: `flowchart TD
                    Boot[Game Start] --> Auto[Auto-Created Subsystem]
                    Level1[Level 1] --"Access"--> Auto
                    Level2[Level 2] --"Access"--> Auto
                    Auto --"Data"--> Persistent[Inventory / Save State]`,
                code: `// --- SaveSubsystem.h ---
UCLASS()
class USaveSubsystem : public UGameInstanceSubsystem {
    GENERATED_BODY()
public:
    void SaveGame();
    void LoadGame();
    
    UPROPERTY()
    TMap<FString, int32> PlayerInventory;
};

// --- Usage ---
USaveSubsystem* SaveSys = GetGameInstance()->GetSubsystem<USaveSubsystem>();
SaveSys->PlayerInventory.Add("HealthPotion", 5);`,
                explanation: `
                    <h3>Global Persistent Logic</h3>
                    <p><code>UGameInstanceSubsystem</code> is the gold standard for global managers that need to exist from the moment the game starts until it closes. They automatically survive level transitions.</p>
                    
                    <h4>Why not GameInstance?</h4>
                    <p>Instead of one massive <code>UGameInstance</code> class with 5000 lines of code, you can have 10 small, focused subsystems (SaveSubsystem, SoundSubsystem, AchievementSubsystem). This makes your code much cleaner and easier to maintain.</p>
                `,
                concepts: ["Persistence", "Modular Managers", "Engine Lifecycles"],
                practices: ["Use for Save/Load logic", "Avoid logic that depends on a specific World", "Clean up delegates in Deinitialize()"]
            },
            {
                id: 213,
                title: "UWorldSubsystem",
                category: "cat-subsystems",
                catName: "Subsystems",
                graph: `flowchart TD
                    Load[Level Load] --> Sub[World Subsystem]
                    Sub --> Manager[Level Score / Timer]
                    Unload[Level Unload] --> Destroy[Subsystem Destroyed]`,
                code: `// --- ScoreSubsystem.h ---
UCLASS()
class UScoreSubsystem : public UWorldSubsystem {
    GENERATED_BODY()
public:
    void AddScore(int32 Amount) { CurrentScore += Amount; }
    
    UPROPERTY()
    int32 CurrentScore = 0;
};

// --- Usage ---
UScoreSubsystem* Score = GetWorld()->GetSubsystem<UScoreSubsystem>();
Score->AddScore(100);`,
                explanation: `
                    <h3>Level-Specific Managers</h3>
                    <p>Unlike GameInstance subsystems, a <code>UWorldSubsystem</code> is tied to the lifecycle of a single level (World). When you change levels, the old subsystem is destroyed and a new one is created for the next world.</p>
                    
                    <h4>Common Uses</h4>
                    <p>Ideal for things that only matter while a level is active: Spawn Managers, Objective Trackers, or Scoreboards for a specific match.</p>
                `,
                concepts: ["Level Lifecycle", "World Context", "Automatic Instantiation"],
                practices: ["Use for level-specific logic", "Don't store data here that needs to persist between levels", "Access via GetWorld()"]
            },
            {
                id: 220,
                title: "Enhanced Input Binding",
                category: "cat-input",
                catName: "Input",
                graph: `flowchart LR
                    IA[Input Action] --"Triggered"--> Func[C++ Function]
                    P[Player] --"Presses Key"--> IA`,
                code: `// --- MyCharacter.h ---
UPROPERTY(EditAnywhere, Category="Input")
TObjectPtr<UInputAction> MoveAction;

// --- MyCharacter.cpp ---
void AMyCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) {
    Super::SetupPlayerInputComponent(PlayerInputComponent);

    if (UEnhancedInputComponent* EIP = CastChecked<UEnhancedInputComponent>(PlayerInputComponent)) {
        EIP->BindAction(MoveAction, ETriggerEvent::Triggered, this, &AMyCharacter::Move);
    }
}

void AMyCharacter::Move(const FInputActionValue& Value) {
    FVector2D MovementVector = Value.Get<FVector2D>();
    AddMovementInput(GetActorForwardVector(), MovementVector.Y);
    AddMovementInput(GetActorRightVector(), MovementVector.X);
}`,
                explanation: `
                    <h3>Binding Actions in UE5</h3>
                    <p>Enhanced Input replaces the old <code>BindAction</code> and <code>BindAxis</code> with a unified system. It uses <code>FInputActionValue</code> to handle everything from simple booleans (buttons) to 2D vectors (thumbsticks).</p>
                    
                    <h4>Trigger Events</h4>
                    <ul>
                        <li><strong>Started:</strong> Fired once when you press the button.</li>
                        <li><strong>Triggered:</strong> Fired every frame while the button is held (useful for movement).</li>
                        <li><strong>Completed:</strong> Fired when you release the button.</li>
                    </ul>
                `,
                concepts: ["Input Binding", "Action Values", "Unified Input"],
                practices: ["Use CastChecked for safety", "Use TObjectPtr for InputAction members", "Keep movement logic in Triggered", "Use Started for one-off actions like Jump"]
            },
            {
                id: 221,
                title: "TSoftObjectPtr (Lazy Loading)",
                category: "cat-assets",
                catName: "Assets",
                graph: `flowchart TD
                    Hard[Hard Pointer] --"Loads"--> Memory[RAM Usage High]
                    Soft[Soft Pointer] --"Wait"--> MemoryLow[RAM Usage Low]
                    Soft --"Async Load"--> RAM[Object Ready]`,
                code: `// --- MyActor.h ---
// Doesn't load the mesh when the actor is created
UPROPERTY(EditAnywhere, Category="Visuals")
TSoftObjectPtr<UStaticMesh> LazyMesh;

// --- MyActor.cpp ---
void AMyActor::LoadAsset() {
    if (LazyMesh.IsPending()) {
        UStaticMesh* Loaded = LazyMesh.LoadSynchronous();
        MeshComp->SetStaticMesh(Loaded);
    }
}`,
                explanation: `
                    <h3>Smart Memory Management</h3>
                    <p>Usually, when you use a raw pointer (<code>UStaticMesh*</code>), Unreal loads that asset into memory the moment the actor exists. This is called "Hard Loading" and can lead to massive RAM usage if you have many variations of an item.</p>
                    
                    <h4>Soft Pointers</h4>
                    <p><code>TSoftObjectPtr</code> stores the <strong>Path</strong> to the asset instead of the asset itself. The asset is only loaded when you explicitly tell it to. This is essential for Open World games and complex inventory systems.</p>
                `,
                concepts: ["Memory Footprint", "Lazy Loading", "Asset Paths"],
                practices: ["Use for large assets (Meshes, Textures)", "Use for optional variations", "Combine with Async Loading for best results"]
            },
            {
                id: 222,
                title: "UAudioComponent Management",
                category: "cat-audio",
                catName: "Audio",
                graph: `flowchart LR
                    Comp[Audio Component] --"SetParam"--> MS[Metasound / Cue]
                    Logic[C++ Logic] --"Play/Stop"--> Comp
                    Comp --"Event"--> Logic`,
                code: `// --- MyActor.cpp ---
AMyActor::AMyActor() {
    AudioComp = CreateDefaultSubobject<UAudioComponent>(TEXT("AudioComp"));
    AudioComp->bAutoActivate = false;
}

void AMyActor::PlayEngineSound(float RPM) {
    if (!AudioComp->IsPlaying()) {
        AudioComp->Play();
    }
    // Update real-time parameters
    AudioComp->SetFloatParameter(FName("EngineRPM"), RPM);
}`,
                explanation: `
                    <h3>Dynamic Soundscapes</h3>
                    <p>While <code>PlaySoundAtLocation</code> is good for one-off explosions, use <code>UAudioComponent</code> when you need to control a sound over time (like an engine idling or a looping ambient wind).</p>
                    
                    <h4>Parameters</h4>
                    <p>Modern UE5 audio (especially <strong>Metasounds</strong>) allows you to send data directly from C++ to the sound engine. You can change pitch, volume, or even complex synth parameters frame-by-frame based on gameplay data.</p>
                `,
                concepts: ["Continuous Audio", "Metasound Parameters", "Audio Control"],
                practices: ["Disable bAutoActivate for manually controlled sounds", "Use FName for parameter keys", "Check IsPlaying() before starting"]
            },
            {
                id: 230,
                title: "meta=(MakeEditWidget)",
                category: "cat-macros",
                catName: "Macros",
                graph: `flowchart LR
                    Prop[FVector Property] --"meta tag"--> Widget[3D Transformation Widget]
                    Widget --"Move in Editor"--> Value[Update Property Value]`,
                code: `// .h
UPROPERTY(EditAnywhere, Category="Offsets", meta=(MakeEditWidget = "true"))
FVector TargetLocation;

// .cpp - Using it
FVector WorldTarget = GetTransform().TransformPosition(TargetLocation);`,
                explanation: `
                    <h3>Visualizing Relative Offsets</h3>
                    <p>When you have an <code>FVector</code> that represents a relative position (like a patrol point or a particle offset), it's hard to guess the coordinates. <code>MakeEditWidget</code> adds a clickable diamond icon in the editor world viewport.</p>
                    
                    <h4>Workflow</h4>
                    <p>Designers can simply drag the widget to the desired spot, and the C++ variable will automatically update with the correct local coordinates. This is far superior to typing numbers manually in the details panel.</p>
                `,
                concepts: ["Editor Experience", "Relative Offsets", "Viewport Widgets"],
                practices: ["Use for patrol points", "Use for spawning offsets", "Remember the value is LOCAL to the actor"]
            },
            {
                id: 231,
                title: "WITH_EDITOR (Editor-Only Code)",
                category: "cat-macros",
                catName: "Macros",
                graph: `flowchart TD
                    Build[Compiler] --"Is Editor Build?"--> Check{Check}
                    Check --"Yes"--> Include[Compile Editor Logic]
                    Check --"No"--> Skip[Strip Code for Performance]`,
                code: `#if WITH_EDITOR
virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override;
#endif

void AMyActor::SomeLogic() {
#if WITH_EDITOR
    DrawDebugSphere(GetWorld(), GetActorLocation(), 100.f, 12, FColor::Red);
#endif
}`,
                explanation: `
                    <h3>Stripping Development Bloat</h3>
                    <p>A lot of the code you write (debug drawings, editor UI, property validation) is only needed while you are making the game. <code>WITH_EDITOR</code> ensures that this code is completely removed from the final "Shipped" version of your game.</p>
                    
                    <h4>Why it matters</h4>
                    <p>This keeps your final executable small and prevents players from accidentally triggering debug functions. It also allows you to use classes (like <code>UnrealEd</code>) that aren't even included in the shipped game engine.</p>
                `,
                concepts: ["Pre-processor Macros", "Build Configurations", "Optimization"],
                practices: ["Wrap all debug drawing", "Wrap PostEditChangeProperty", "Never put gameplay-critical logic inside WITH_EDITOR"]
            },
            {
                id: 232,
                title: "OnConstruction (C++ Script)",
                category: "cat-lifecycle",
                catName: "Lifecycle",
                graph: `flowchart LR
                    Move[Move Actor in Level] --> OnCons[OnConstruction]
                    OnCons --> Update[Update Meshes/Lights/Materials]
                    Update --> Visual[Immediate Feedback]`,
                code: `// --- MyActor.cpp ---
void AMyActor::OnConstruction(const FTransform& Transform) {
    Super::OnConstruction(Transform);

    // Dynamic procedural setup
    DynamicMaterial = CreateDynamicMaterialInstance(BaseMaterial);
    DynamicMaterial->SetVectorParameterValue(TEXT("Color"), TeamColor);
    
    MeshComp->SetMaterial(0, DynamicMaterial);
}`,
                explanation: `
                    <h3>Live Editor Updates</h3>
                    <p><code>OnConstruction</code> is the C++ equivalent of the <strong>Construction Script</strong> in Blueprints. It runs whenever you move the actor or change a property in the editor, providing instant visual feedback.</p>
                    
                    <h4>Difference from Constructor</h4>
                    <p>The Constructor only runs once when the object is first created. <code>OnConstruction</code> runs every time the actor is modified. This makes it the perfect place for "procedural" setup, like changing a character's clothing based on an enum.</p>
                `,
                concepts: ["Construction Script", "Procedural Generation", "Editor Feedback"],
                practices: ["Keep it efficient (runs on every drag)", "Use for visual-only setup", "Always call Super::OnConstruction"]
            },
            {
                id: 233,
                title: "PostInitializeComponents",
                category: "cat-lifecycle",
                catName: "Lifecycle",
                graph: `flowchart TD
                    Constructor[Constructor] --> PreInit[PreInitializeComponents]
                    PreInit --> CompInit[Components Initialized]
                    CompInit --> PostInit[PostInitializeComponents]
                    PostInit --> BeginPlay[BeginPlay]`,
                code: `// --- MyActor.cpp ---
void AMyActor::PostInitializeComponents() {
    Super::PostInitializeComponents();

    // All components are now valid and initialized.
    // Perfect place to bind delegates between components.
    if (HealthComp && UIComp) {
        HealthComp->OnHealthChanged.AddDynamic(UIComp, &UMyUIComp::UpdateBar);
    }
}`,
                explanation: `
                    <h3>Cross-Component Wiring</h3>
                    <p>When you create components in the Constructor, they aren't "ready" yet. <code>PostInitializeComponents</code> is the lifecycle hook that fires after every component on the actor has been fully initialized but <em>before</em> <code>BeginPlay</code> runs.</p>
                    
                    <h4>Why use it?</h4>
                    <p>It's the safest place to cache references to your own components and bind their delegates to each other. By the time <code>BeginPlay</code> runs, your components are already "talking" to each other, preventing many initialization order bugs.</p>
                `,
                concepts: ["Initialization Order", "Component Communication", "Lifecycle Synchronization"],
                practices: ["Always call Super first", "Avoid world-dependent logic (use BeginPlay for that)", "Validate component pointers before binding"]
            },
            {
                id: 234,
                title: "OverlapMultiByChannel",
                category: "cat-phys",
                catName: "Physics",
                graph: `flowchart LR
                    Center[Sphere Center] --"Radius"--> Vol[Detection Volume]
                    Vol --"Find All"--> List[Array of Overlapping Actors]`,
                code: `TArray<FOverlapResult> Overlaps;
FCollisionShape Sphere = FCollisionShape::MakeSphere(500.f);
FCollisionQueryParams Params;
Params.AddIgnoredActor(this);

bool bHit = GetWorld()->OverlapMultiByChannel(
    Overlaps,
    GetActorLocation(),
    FQuat::Identity,
    ECC_WorldDynamic,
    Sphere,
    Params
);

for (const FOverlapResult& Result : Overlaps) {
    AActor* OverlappedActor = Result.GetActor();
    // Deal AoE damage...
}`,
                explanation: `
                    <h3>Area of Effect Detection</h3>
                    <p>Unlike a Line Trace which only finds what's directly in front of you, <code>OverlapMultiByChannel</code> finds <strong>every</strong> actor within a specific shape (Sphere, Box, or Capsule).</p>
                    
                    <h4>Performance</h4>
                    <p>Finding many actors at once is more expensive than a single trace. Use this for one-off events like an explosion or a "radar pulse", but avoid doing it every frame in <code>Tick</code> if you can use overlap events on a component instead.</p>
                `,
                concepts: ["AoE Logic", "Physics Queries", "Collision Channels"],
                practices: ["Ignore 'this' to avoid hitting yourself", "Use for explosions or proximity checks", "Limit the frequency of multi-overlaps"]
            },
            {
                id: 235,
                title: "WidgetComponent (3D UI)",
                category: "cat-ui",
                catName: "UI",
                graph: `flowchart LR
                    Actor[Enemy Character] --> WC[Widget Component]
                    WC --"Screen/World Space"--> UI[Floating Health Bar]`,
                code: `// --- MyCharacter.cpp ---
AMyCharacter::AMyCharacter() {
    HealthWidget = CreateDefaultSubobject<UWidgetComponent>(TEXT("HealthWidget"));
    HealthWidget->SetupAttachment(RootComponent);
    
    // Set to Screen space so it always faces the player
    HealthWidget->SetWidgetSpace(EWidgetSpace::Screen);
    HealthWidget->SetDrawSize(FVector2D(100.f, 20.f));
}`,
                explanation: `
                    <h3>Floating Head-Up Displays</h3>
                    <p>The <code>WidgetComponent</code> is how you attach 2D UMG widgets to 3D actors in the world. This is most commonly used for floating health bars, nameplates, or interactive computer screens.</p>
                    
                    <h4>Screen vs World Space</h4>
                    <ul>
                        <li><strong>Screen Space:</strong> The UI stays the same size regardless of distance and always faces the camera (perfect for Health Bars).</li>
                        <li><strong>World Space:</strong> The UI is treated like a physical object in the level (perfect for an in-game terminal).</li>
                    </ul>
                `,
                concepts: ["UMG in 3D", "Space Transformations", "Billboarding"],
                practices: ["Use Screen space for readability", "Optimize Tick frequency for distant widgets", "Use SetWidgetClass in the constructor"]
            },
            {
                id: 236,
                title: "TSet (Unique Collections)",
                category: "cat-data",
                catName: "Data",
                graph: `flowchart LR
                    Input[Items: A, B, A, C] --> Set[TSet]
                    Set --> Output[Result: A, B, C]
                    Set --"O(1)"--> Fast[Lightning Fast Search]`,
                code: `TSet<AActor*> EncounteredEnemies;

void AMyChar::OnSeeEnemy(AActor* Enemy) {
    // Only adds if it's not already in the list
    EncounteredEnemies.Add(Enemy);
    
    // Lightning fast lookup
    if (EncounteredEnemies.Contains(SpecialBoss)) {
        UE_LOG(LogTemp, Warning, TEXT("The Boss has been spotted!"));
    }
}`,
                explanation: `
                    <h3>Speed and Uniqueness</h3>
                    <p>While <code>TArray</code> is the most common container, <code>TSet</code> is superior when you need to ensure every item is unique and you need to search for items extremely fast.</p>
                    
                    <h4>Hashing</h4>
                    <p>Behind the scenes, <code>TSet</code> uses a "Hash Table". This means checking if an item exists takes the same amount of time whether you have 10 items or 10,000 items (O(1) complexity), whereas <code>TArray</code> gets slower as it grows.</p>
                `,
                concepts: ["Hash Tables", "O(1) Complexity", "Uniqueness Enforcement"],
                practices: ["Use for 'Already Seen' lists", "Use for large collections you search often", "Note: TSet does not preserve order"]
            },
            {
                id: 237,
                title: "TObjectPtr (Modern Pointers)",
                category: "cat-cpp",
                catName: "C++",
                graph: `flowchart LR
                    Old[UObject* Raw] --"Evolution"--> New[TObjectPtr]
                    New --"Optional"--> Access[Lazy Access / Tracking]`,
                code: `// --- Modern UE5 Header ---
UPROPERTY(EditAnywhere, Category="Mesh")
TObjectPtr<UStaticMesh> MainMesh;

void AMyActor::BeginPlay() {
    // Usage is identical to raw pointers
    if (MainMesh) {
        float Size = MainMesh->GetBounds().SphereRadius;
    }
}`,
                explanation: `
                    <h3>The UE5 Standard</h3>
                    <p>In Unreal Engine 5, <code>TObjectPtr</code> has replaced raw pointers (<code>UObject*</code>) for class properties. While they behave like raw pointers in most cases, they allow the engine to perform "Lazy Loading" and better access tracking in editor builds.</p>
                    
                    <h4>When to use?</h4>
                    <p>You should use <code>TObjectPtr</code> for any <code>UPROPERTY</code> member variables in your header files. Inside function bodies (local variables), you should still use raw pointers for simplicity and performance.</p>
                `,
                concepts: ["Pointer Wrapping", "Memory Tracking", "UE5 Coding Standards"],
                practices: ["Use for all UPROPERTY pointers", "Use raw pointers for local variables", "Use .Get() if you need the raw pointer explicitly"]
            },
            {
                id: 240,
                title: "UAnimNotify (C++)",
                category: "cat-anim",
                catName: "Animation",
                graph: `flowchart LR
                    Anim[Animation Frame] --> Notify[C++ Notify]
                    Notify --> VFX[Spawn Blood/Dust]
                    Notify --> SFX[Play Footstep]`,
                code: `// --- MyAnimNotify.h ---
UCLASS()
class UMyAnimNotify : public UAnimNotify {
    GENERATED_BODY()
    virtual void Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference) override;
};

// --- MyAnimNotify.cpp ---
void UMyAnimNotify::Notify(USkeletalMeshComponent* MeshComp, ...) {
    if (MeshComp && MeshComp->GetOwner()) {
        // Trigger gameplay logic or visuals
        SpawnEffectAtSocket(MeshComp, TEXT("Foot_R"));
    }
}`,
                explanation: `
                    <h3>Frame-Perfect Triggers</h3>
                    <p>AnimNotifies are markers placed in an animation that trigger code at a specific frame. While you can create them in Blueprints, writing them in C++ is more performant and allows for complex logic shared across many characters.</p>
                    
                    <h4>Common Uses</h4>
                    <p>Footstep sounds, particle bursts, weapon trails, or triggering specific gameplay states (like "Can branch to next combo") at the exact moment of a swing.</p>
                `,
                concepts: ["Animation Events", "Visual/Gameplay Sync", "Performance"],
                practices: ["Avoid heavy logic in Notify", "Check for valid Mesh/Owner", "Use for one-shot effects"]
            },
            {
                id: 241,
                title: "UAnimNotifyState (Windows)",
                category: "cat-anim",
                catName: "Animation",
                graph: `flowchart LR
                    Start[Start Frame] --> Active[Active State]
                    Active --> End[End Frame]
                    Active --"Every Frame"--> Logic[Trace for Hits]`,
                code: `// --- MyNotifyState.cpp ---
void UMyNotifyState::NotifyBegin(USkeletalMeshComponent* MeshComp, ...) {
    // Start tracing/effects
}

void UMyNotifyState::NotifyTick(USkeletalMeshComponent* MeshComp, ...) {
    // Logic that runs every frame of the window
}

void UMyNotifyState::NotifyEnd(USkeletalMeshComponent* MeshComp, ...) {
    // Stop tracing/cleanup
}`,
                explanation: `
                    <h3>State Windows</h3>
                    <p>Unlike a standard Notify which fires once, <code>UAnimNotifyState</code> defines a <strong>Duration</strong> (a window of time). It has three hooks: Begin, Tick, and End.</p>
                    
                    <h4>Combat Hitboxes</h4>
                    <p>This is the industry-standard way to handle melee hitboxes. You start the trace in <code>NotifyBegin</code> and stop it in <code>NotifyEnd</code>, ensuring the weapon only deals damage during the "active" part of the swing.</p>
                `,
                concepts: ["Duration Notifies", "Melee Logic", "Component Activation"],
                practices: ["Use for hitbox windows", "Use for continuous VFX (e.g. flames)", "Clean up state in NotifyEnd"]
            },
            {
                id: 242,
                title: "UNavigationSystemV1",
                category: "cat-ai",
                catName: "AI",
                graph: `flowchart LR
                    Raw[Point in Level] --"Project"--> Nav[Valid Point on NavMesh]
                    Nav --"Query"--> Path[Optimal Path to Player]`,
                code: `UNavigationSystemV1* NavSys = FNavigationSystem::GetCurrent<UNavigationSystemV1>(GetWorld());

if (NavSys) {
    FNavLocation Result;
    bool bFound = NavSys->GetRandomReachablePointInRadius(
        GetActorLocation(), 
        2000.f, 
        Result
    );
    
    if (bHit) {
        FVector TargetPoint = Result.Location;
    }
}`,
                explanation: `
                    <h3>Navigating the World</h3>
                    <p>In UE5, AI doesn't just "move" to a location; it needs to know if that location is reachable on the <strong>NavMesh</strong>. The <code>UNavigationSystemV1</code> is the gateway to these queries.</p>
                    
                    <h4>Smart Pathfinding</h4>
                    <p>You can use the navigation system to find random points for patrolling, check if a player is standing on the ground (ProjectPointToNavigation), or calculate the total distance of a path before the AI even starts moving.</p>
                `,
                concepts: ["Pathfinding", "NavMesh Queries", "Spatial Reasoning"],
                practices: ["Always check if NavSys is valid", "Use ProjectPointToNavigation to snap points to ground", "Radius queries are great for 'Wander' logic"]
            },
            {
                id: 243,
                title: "UGameplayAbility (C++)",
                category: "cat-gas",
                catName: "GAS",
                graph: `flowchart TD
                    Act[ActivateAbility] --> Check[Check Costs/Cooldown]
                    Check --"Pass"--> Logic[Gameplay Logic]
                    Logic --"Wait"--> Task[Ability Task]
                    Task --"Done"--> End[EndAbility]`,
                code: `// --- MyAbility.cpp ---
void UMyAbility::ActivateAbility(...) {
    if (!CommitAbility(Handle, ActorInfo, ActivationInfo)) {
        EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
        return;
    }

    // Play Montage, Spawn Projectile, etc.
    // ...
    
    EndAbility(Handle, ActorInfo, ActivationInfo, true, false);
}`,
                explanation: `
                    <h3>C++ Ability Logic</h3>
                    <p>A <code>UGameplayAbility</code> is a self-contained unit of logic, like "Fireball", "Jump", or "Heavy Attack". It manages its own lifecycle, cooldowns, and costs (Mana/Stamina).</p>
                    
                    <h4>CommitAbility</h4>
                    <p>The call to <code>CommitAbility</code> is vital. It checks if the player has enough mana and if the ability is off cooldown. If it returns false, the ability should be terminated immediately.</p>
                `,
                concepts: ["Ability Lifecycle", "Cost & Cooldown", "GAS Architecture"],
                practices: ["Always call CommitAbility", "Always call EndAbility when finished", "Use Ability Tasks for latent logic"]
            },
            {
                id: 250,
                title: "IMC Management (Input)",
                category: "cat-input",
                catName: "Input",
                graph: `flowchart LR
                    Start[BeginPlay] --> Add[Add Mapping Context]
                    Enter[Enter Car] --> Swap[Swap IMC: Foot -> Driving]
                    Swap --"Priority"--> Over[New Inputs Override Old]`,
                code: `// --- MyCharacter.cpp ---
void AMyCharacter::PawnClientRestart() {
    Super::PawnClientRestart();

    if (APlayerController* PC = Cast<APlayerController>(GetController())) {
        if (UEnhancedInputLocalPlayerSubsystem* Sub = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(PC->GetLocalPlayer())) {
            // Priority 0: Base controls
            Sub->AddMappingContext(DefaultIMC, 0);
        }
    }
}`,
                explanation: `
                    <h3>Dynamic Input Contexts</h3>
                    <p>One of the biggest advantages of Enhanced Input is the ability to swap <strong>Input Mapping Contexts (IMC)</strong> at runtime. You can have a "Base" context for walking and a "UI" context for menus.</p>
                    
                    <h4>Priority Levels</h4>
                    <p>When you add an IMC, you give it a Priority number. If two contexts use the same button (e.g., Space Bar), the one with the <strong>Higher Priority</strong> wins. This makes handling vehicles, mounting, or mini-games extremely simple.</p>
                `,
                concepts: ["Input Contexts", "Dynamic Remapping", "Priority Layers"],
                practices: ["Add base IMC in PawnClientRestart", "Use higher priority for temporary states (driving, menus)", "Remove IMC when state ends"]
            },
            {
                id: 251,
                title: "FStreamableManager (Async)",
                category: "cat-assets",
                catName: "Assets",
                graph: `flowchart LR
                    Request[Asset Path] --> Manager[Streamable Manager]
                    Manager --"Async"--> Load[Loading in Background]
                    Load --"Callback"--> Ready[Asset Ready to Use]`,
                code: `// --- MyActor.cpp ---
void AMyActor::StartAsyncLoad() {
    FStreamableManager& Manager = UAssetManager::GetStreamableManager();
    FSoftObjectPath Path = LazyMesh.ToSoftObjectPath();
    
    // Non-blocking load
    Handle = Manager.RequestAsyncLoad(Path, FStreamableDelegate::CreateUObject(this, &AMyActor::OnLoadComplete));
}

void AMyActor::OnLoadComplete() {
    UStaticMesh* Loaded = LazyMesh.Get();
    MeshComp->SetStaticMesh(Loaded);
}`,
                explanation: `
                    <h3>Smooth Asset Loading</h3>
                    <p>If you use <code>LoadSynchronous</code>, the game will "hitch" or freeze for a few milliseconds while the file is read from the disk. <code>FStreamableManager</code> allows you to load assets in the background without affecting the frame rate.</p>
                    
                    <h4>Delegates</h4>
                    <p>Since the load happens in the background, you provide a <strong>Delegate</strong> (a function) that the engine will call automatically once the asset is ready. This is the professional way to handle spawning enemies or changing equipment during gameplay.</p>
                `,
                concepts: ["Asynchronous I/O", "Thread Safety", "Hitch Prevention"],
                practices: ["Always async load during active gameplay", "Keep the manager reference safe", "Check if asset is still valid after load"]
            },
            {
                id: 252,
                title: "PlaySoundAtLocation",
                category: "cat-audio",
                catName: "Audio",
                graph: `flowchart LR
                    Trigger[Hit/Explosion] --> Play[PlaySoundAtLocation]
                    Play --"Spatial"--> Pos[3D Position]
                    Pos --"Attenuation"--> Hear[Player Hears]`,
                code: `// One-shot spatialized audio
UGameplayStatics::PlaySoundAtLocation(
    this, 
    ExplosionSound, 
    GetActorLocation(), 
    FRotator::ZeroRotator,
    1.0f, // Volume
    1.0f, // Pitch
    0.0f, // Start Time
    SoundAttenuation // Spatial settings
);`,
                explanation: `
                    <h3>Fire-and-Forget Audio</h3>
                    <p>For sounds that don't need to be tracked or stopped (like a footstep, a gunshot, or an explosion), <code>PlaySoundAtLocation</code> is the most efficient choice. It spawns the sound and cleans itself up automatically.</p>
                    
                    <h4>Spatialization</h4>
                    <p>By providing a location and an <strong>Attenuation Asset</strong>, the engine handles the 3D positioning. The sound will be louder if the player is close and will pan between the speakers as the player turns.</p>
                `,
                concepts: ["Spatial Audio", "Attenuation", "One-shot Effects"],
                practices: ["Use for short, non-looping sounds", "Provide an Attenuation asset for 3D depth", "Avoid for sounds that need to stop early"]
            },
            {
                id: 253,
                title: "FQuat (Quaternions)",
                category: "cat-math",
                catName: "Math",
                graph: `flowchart TD
                    Rot[FRotator] --"Limits"--> Gimbal[Gimbal Lock at 90Â°]
                    Quat[FQuat] --"Stability"--> Smooth[Perfect 360Â° Movement]`,
                code: `// Slerp (Spherical Linear Interpolation) between rotations
FQuat StartQuat = GetActorQuat();
FQuat TargetQuat = FQuat(FRotator(0, 90, 0));

FQuat SmoothQuat = FQuat::Slerp(StartQuat, TargetQuat, DeltaTime * 5.f);
SetActorRotation(SmoothQuat);`,
                explanation: `
                    <h3>Gimbal-Free Rotation</h3>
                    <p>While <code>FRotator</code> (Pitch/Yaw/Roll) is easy to understand, it fails when you look straight up or downâ€”this is called <strong>Gimbal Lock</strong>. Quaternions (<code>FQuat</code>) use 4D math to represent rotation, which is perfectly stable at any angle.</p>
                    
                    <h4>SLERP</h4>
                    <p>The greatest advantage of Quaternions is <strong>Slerp</strong>. Unlike a standard Interp which might take a "weird" path between angles, Slerp always takes the mathematically shortest and smoothest path on a sphere.</p>
                `,
                concepts: ["Mathematical Stability", "Gimbal Lock Prevention", "SLERP"],
                practices: ["Use for space flight or complex physics", "Convert back to FRotator for UI", "Always normalize Quaternions after math"]
            },
            {
                id: 260,
                title: "Single-Cast Delegates",
                category: "cat-events",
                catName: "Events",
                graph: `flowchart LR
                    Sender[System A] --"Question?"--> Del[Delegate]
                    Del --"Execution"--> Receiver[System B]
                    Receiver --"Answer"--> Sender`,
                code: `// .h - Declaration
DECLARE_DELEGATE_RetVal_OneParam(bool, FCheckCanInteract, AActor*);

// Class Property
FCheckCanInteract CanInteractDelegate;

// .cpp - Usage
if (CanInteractDelegate.IsBound()) {
    bool bAllowed = CanInteractDelegate.Execute(PlayerActor);
}`,
                explanation: `
                    <h3>One-to-One Communication</h3>
                    <p>Unlike Multicast delegates which "Broadcast" to everyone, a Single-cast delegate is a private line between two objects. Its biggest advantage is that it can **Return a Value**.</p>
                    
                    <h4>Why use it?</h4>
                    <p>Use it when one system needs to "Ask a Question" of another system. For example, a Combat System might ask an Inventory System: "Does the player have enough arrows to fire?" before playing the animation.</p>
                `,
                concepts: ["Return Values", "Tight Coupling", "Callback Patterns"],
                practices: ["Always use IsBound() before Execute()", "Use for logic gates/checks", "Binding is done via BindUObject or BindSP"]
            },
            {
                id: 261,
                title: "AGameModeBase (Rules)",
                category: "cat-framework",
                catName: "Framework",
                graph: `flowchart TD
                    Engine[Engine Startup] --> GM[Game Mode]
                    GM --"Rules"--> GS[Game State]
                    GM --"Spawn"--> PC[Player Controller]
                    GM --"Spawn"--> Pawn[Character]`,
                code: `// --- MyGameMode.cpp ---
AMyGameMode::AMyGameMode() {
    // Define the "Identity" of your game
    DefaultPawnClass = AMyPlayer::StaticClass();
    PlayerControllerClass = AMyController::StaticClass();
    GameStateClass = AMyGameState::StaticClass();
}

void AMyGameMode::PostLogin(APlayerController* NewPlayer) {
    Super::PostLogin(NewPlayer);
    // Logic to run when a player enters the world
}`,
                explanation: `
                    <h3>The Game's Referee</h3>
                    <p>The <code>GameMode</code> is the absolute authority of your game level. It defines the rules, decides who wins or loses, and handles the spawning of players.</p>
                    
                    <h4>Single Player Focus</h4>
                    <p>Even in single-player, the GameMode is essential for managing match flow (e.g., "Starting", "In Progress", "Game Over"). It is the only class that is guaranteed to exist only on the Server (which, in single-player, is just your computer).</p>
                `,
                concepts: ["Match Lifecycle", "Class Defaults", "Actor Spawning"],
                practices: ["Keep match rules here", "Use for level-start initialization", "Access via GetWorld()->GetAuthGameMode()"]
            },
            {
                id: 262,
                title: "APlayerState (Persistence)",
                category: "cat-framework",
                catName: "Framework",
                graph: `flowchart LR
                    Pawn[Character Body] --"Dies"--> Dead[Destroyed]
                    PS[Player State] --"Survives"--> Respawn[New Body]
                    PS --"Holds"--> Score[Gold / XP / Stats]`,
                code: `// --- MyPlayerState.h ---
UCLASS()
class AMyPlayerState : public APlayerState {
    GENERATED_BODY()
public:
    UPROPERTY(BlueprintReadOnly, Category="Stats")
    int32 PlayerScore;

    UPROPERTY(BlueprintReadOnly, Category="Stats")
    int32 TeamID;
};`,
                explanation: `
                    <h3>The Player's Identity</h3>
                    <p>While the <code>Pawn</code> is just a physical "Puppet" that can be killed and replaced, the <code>PlayerState</code> is the "Soul" of the player. It holds all the data that should survive even if the character dies.</p>
                    
                    <h4>Persistence</h4>
                    <p>If your player dies and respawns, their score, XP, and inventory should usually stay with them. Storing this data in the PlayerState ensures it isn't lost when the character actor is destroyed.</p>
                `,
                concepts: ["Data Persistence", "Player Identity", "Session Stats"],
                practices: ["Store XP and Gold here", "Use for GAS Attribute ownership", "Access via Pawn->GetPlayerState()"]
            },
            {
                id: 263,
                title: "TMap (Key-Value Pairs)",
                category: "cat-data",
                catName: "Data",
                graph: `flowchart LR
                    Key[Name: 'IronSword'] --"Lookup"--> Value[Data: Damage=50]
                    Key2[Name: 'HealthPot'] --"Lookup"--> Value2[Data: Heal=20]`,
                code: `// An inventory mapping Item Names to Quantity
TMap<FName, int32> Inventory;

// Adding items
Inventory.Add(TEXT("Gold"), 100);

// Retrieving safely
if (int32* Amount = Inventory.Find(TEXT("Gold"))) {
    *Amount += 50;
}

// Removing
Inventory.Remove(TEXT("OldKey"));`,
                explanation: `
                    <h3>The Dictionary Container</h3>
                    <p><code>TMap</code> allows you to associate a <strong>Key</strong> (like a Name or an ID) with a <strong>Value</strong> (like an Actor pointer or a Struct). It is perfect for inventories, stat sheets, or settings.</p>
                    
                    <h4>Performance</h4>
                    <p>Like TSet, TMaps are incredibly fast for lookups. Finding an item by its name in a TMap is significantly faster than looping through a TArray to find a matching string.</p>
                `,
                concepts: ["Key-Value Association", "Fast Lookup", "Data Mapping"],
                practices: ["Use FName for keys where possible", "Use Find() to avoid double lookups", "Note: TMap is not blueprint-editable by default (use USTRUCT if needed)"]
            },
            {
                id: 270,
                title: "FGameplayTagContainer",
                category: "cat-gas",
                catName: "GAS",
                graph: `flowchart TD
                    Cont[Tag Container] --> T1[Status.Burning]
                    Cont --> T2[Status.Stunned]
                    Cont --> T3[Debuff.Frozen]
                    Logic[Check] --"Has Tag?"--> Cont`,
                code: `FGameplayTagContainer MyTags;
MyTags.AddTag(FGameplayTag::RequestGameplayTag(TEXT("Status.Stunned")));

// Hierarchical check
if (MyTags.HasTag(FGameplayTag::RequestGameplayTag(TEXT("Status")))) {
    // Returns TRUE because Stunned is a child of Status
    StopMovement();
}`,
                explanation: `
                    <h3>Hierarchical Labeling</h3>
                    <p>Gameplay Tags are strings that act like "Labels" for actors or states. Unlike Enums which can only have one value, a <code>FGameplayTagContainer</code> can hold many tags at once.</p>
                    
                    <h4>The Power of Hierarchy</h4>
                    <p>Tags are hierarchical (separated by dots). If you check if an actor has the tag <code>Status</code>, it will return true if they have <code>Status.Poisoned</code>, <code>Status.Burning</code>, or <code>Status.Stunned</code>. This makes "Broad" checks extremely easy to write.</p>
                `,
                concepts: ["Labeling Systems", "Hierarchical Logic", "Data-Driven Tags"],
                practices: ["Avoid hard-coding tag names (use native tags if possible)", "Use containers for overlapping states", "Leverage hierarchy for generic checks"]
            },
            {
                id: 271,
                title: "Input Modifiers (Curves)",
                category: "cat-input",
                catName: "Input",
                graph: `flowchart LR
                    Raw[Raw Stick Input] --> Mod[Modifier: Deadzone]
                    Mod --> Curve[Modifier: Sensitivity Curve]
                    Curve --> Final[Smooth Character Turn]`,
                code: `// Adding a modifier via C++ (rare, usually in BP asset)
UInputModifierDeadZone* Deadzone = NewObject<UInputModifierDeadZone>();
Deadzone->LowerThreshold = 0.2f;

MyAction->Modifiers.Add(Deadzone);`,
                explanation: `
                    <h3>Sanitizing Player Input</h3>
                    <p>Input Modifiers allow you to change the "Raw" data from a controller before it reaches your gameplay logic. This is perfect for handling "Dead-zones" (drifting sticks) or "Sensitivity Curves".</p>
                    
                    <h4>Dead-zones</h4>
                    <p>A dead-zone modifier ignores small inputs near the center of the stick. Without this, a player's character might slowly crawl forward even if they aren't touching the controller.</p>
                `,
                concepts: ["Data Transformation", "Player Comfort", "Signal Processing"],
                practices: ["Use for stick sensitivity", "Use for inverting axes", "Configure in the Input Action asset for best workflow"]
            },
            {
                id: 272,
                title: "UPrimaryDataAsset",
                category: "cat-assets",
                catName: "Assets",
                graph: `flowchart TD
                    DA[Data Asset] --> Val1[Damage: 100]
                    DA --> Val2[Mesh: Sword_Model]
                    DA --> Val3[Sound: Swing_Wav]
                    Logic[Weapon Code] --"Reads"--> DA`,
                code: `// --- WeaponData.h ---
UCLASS()
class UWeaponData : public UPrimaryDataAsset {
    GENERATED_BODY()
public:
    UPROPERTY(EditAnywhere)
    float Damage;

    UPROPERTY(EditAnywhere)
    TSoftObjectPtr<UStaticMesh> Model;
};`,
                explanation: `
                    <h3>The Designer's Toolbox</h3>
                    <p><code>UPrimaryDataAsset</code> is the best way to store "Buckets" of data that designers can edit. Instead of hard-coding values for 50 different swords, you create 50 Data Assets.</p>
                    
                    <h4>Asset Manager</h4>
                    <p>By using <strong>Primary</strong> Data Assets, you allow the engine's <code>AssetManager</code> to track them. This makes it easy to "Find all Weapons" or "Load all Potions" at runtime without needing to manually link them in a list.</p>
                `,
                concepts: ["Data-Driven Design", "Asset Tracking", "Configuration"],
                practices: ["Use for items, quests, and stats", "Avoid putting logic inside data assets", "Use Soft Pointers for visual assets inside"]
            },
            {
                id: 273,
                title: "Metasounds C++ Interface",
                category: "cat-audio",
                catName: "Audio",
                graph: `flowchart LR
                    Logic[Health %] --> Float[C++ SetFloat]
                    Float --> MS[Metasound Graph]
                    MS --"Dynamic"--> SFX[Glitchy Heartbeat Effect]`,
                code: `// Modulating a sound based on health
UAudioComponent* AC = ...;
float HealthPercent = CurrentHP / MaxHP;

// Set parameter defined in the Metasound Graph
AC->SetFloatParameter(TEXT("HealthIntensity"), HealthPercent);

// Trigger a sound event
AC->SetTriggerParameter(TEXT("OnTakeDamage"));`,
                explanation: `
                    <h3>Procedural Audio Control</h3>
                    <p>Metasounds are the new procedural audio graphs in UE5. Unlike old Sound Cues, they are fully programmable and can react to data in real-time.</p>
                    
                    <h4>Dynamic Parameters</h4>
                    <p>You can send any data (Floats, Booleans, Triggers) from your C++ logic into the Metasound. This allows the audio to "Evolve" as the game state changesâ€”for example, making the music more intense as the player's health drops.</p>
                `,
                concepts: ["Procedural Audio", "Real-time Modulation", "Sound Synthesis"],
                practices: ["Use Triggers for precise timing", "Match parameter names EXACTLY", "Cache the AudioComponent reference"]
            },
            {
                id: 274,
                title: "SweepSingleByChannel",
                category: "cat-phys",
                catName: "Physics",
                graph: `flowchart LR
                    Start[Start Pos] --"Move Shape"--> End[End Pos]
                    Shape[Sphere/Box] --"Collides"--> Hit[FHitResult]
                    Hit --> Data[Exact Impact Point]`,
                code: `FHitResult Hit;
FVector Start = GetActorLocation();
FVector End = Start + (GetActorForwardVector() * 200.f);
FCollisionShape MyBox = FCollisionShape::MakeBox(FVector(50, 50, 50));

bool bHit = GetWorld()->SweepSingleByChannel(
    Hit,
    Start,
    End,
    FQuat::Identity,
    ECC_Visibility,
    MyBox
);`,
                explanation: `
                    <h3>Volumetric Collision</h3>
                    <p>While a Line Trace is a single "Infinitely Thin" beam, a <strong>Sweep</strong> moves a physical 3D shape (like a box or sphere) through space to see if it hits anything.</p>
                    
                    <h4>Why Sweep?</h4>
                    <p>Use a sweep when you need to know if a character can "Fit" through an opening, or for large projectiles (like a boulder) where a single thin line would be too small to accurately detect hits.</p>
                `,
                concepts: ["Physical Volume", "Collision Geometry", "Intersection Tests"],
                practices: ["Use for thick projectiles", "Use for 'Can Character Fit' checks", "Be mindful of performance vs Line Traces"]
            },
            {
                id: 275,
                title: "UKismetMathLibrary::VInterpTo",
                category: "cat-math",
                catName: "Math",
                graph: `flowchart LR
                    A[Current Location] --"VInterpTo"--> B[Target Location]
                    B --"Speed"--> Smooth[Smooth Movement Path]`,
                code: `// Inside Tick
FVector Current = GetActorLocation();
FVector Target = FollowTarget->GetActorLocation();

FVector NewPos = UKismetMathLibrary::VInterpTo(
    Current, 
    Target, 
    DeltaTime, 
    2.0f // Interp Speed
);

SetActorLocation(NewPos);`,
                explanation: `
                    <h3>Smoothing Position Changes</h3>
                    <p><code>VInterpTo</code> is the vector version of interpolation. It calculates a smooth path between two 3D points over several frames.</p>
                    
                    <h4>Ease-In/Out</h4>
                    <p>The standard <code>VInterpTo</code> uses an exponential curveâ€”it moves fast at the start and slows down as it reaches the target. For a constant, linear speed, use <code>VInterpTo_Constant</code> instead.</p>
                `,
                concepts: ["Motion Smoothing", "Vector Math", "Juice"],
                practices: ["Higher speed = more responsive", "Lower speed = floatier feel", "Always use DeltaTime for frame-rate independence"]
            },
            {
                id: 280,
                title: "UBTService (AI Logic)",
                category: "cat-ai",
                catName: "AI",
                graph: `flowchart TD
                    Node[Behavior Tree Node] --> Serv[C++ Service]
                    Serv --"Interval: 0.5s"--> Tick[TickNode]
                    Tick --> Update[Update Blackboard]`,
                code: `// --- BTService_CheckDistance.h ---
UCLASS()
class UBTService_CheckDistance : public UBTService {
    GENERATED_BODY()
protected:
    virtual void TickNode(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory, float DeltaSeconds) override;
};

// --- BTService_CheckDistance.cpp ---
void UBTService_CheckDistance::TickNode(UBehaviorTreeComponent& OwnerComp, ...) {
    APawn* Player = UGameplayStatics::GetPlayerPawn(GetWorld(), 0);
    float Dist = FVector::Dist(OwnerComp.GetAIOwner()->GetPawn()->GetActorLocation(), Player->GetActorLocation());
    
    OwnerComp.GetBlackboardComponent()->SetValueAsFloat(FName("DistToPlayer"), Dist);
}`,
                explanation: `
                    <h3>Recurring AI Checks</h3>
                    <p>A <code>UBTService</code> is logic that runs at a set interval (e.g., every 0.5 seconds) as long as its branch of the Behavior Tree is active. This is much more efficient than checking conditions every single frame.</p>
                    
                    <h4>Optimization</h4>
                    <p>Use services to update the <strong>Blackboard</strong>. For example, a service can constantly update the "Distance to Player" value, allowing Decorators elsewhere in the tree to react instantly to changes.</p>
                `,
                concepts: ["Optimization", "Blackboard Updates", "BT Infrastructure"],
                practices: ["Use for state updates", "Set a random deviation to interval to prevent AI 'syncing'", "Avoid complex pathfinding inside services"]
            },
            {
                id: 281,
                title: "FGameplayEffectContextHandle",
                category: "cat-gas",
                catName: "GAS",
                graph: `flowchart LR
                    Source[Attacker] --"Context"--> Effect[Gameplay Effect]
                    Effect --"Payload"--> Target[Defender]
                    Target --"Extract"--> Hit[Hit Location / Bone]`,
                code: `// Passing hit data through GAS
FGameplayEffectContextHandle Context = ASC->MakeEffectContext();
Context.AddHitResult(MyHitResult);

FGameplayEffectSpecHandle Spec = ASC->MakeOutgoingSpec(EffectClass, 1.f, Context);
ASC->ApplyGameplayEffectSpecToTarget(*Spec.Data.Get(), TargetASC);`,
                explanation: `
                    <h3>Carrying Hit Data</h3>
                    <p>When you apply a Gameplay Effect (like damage), you often need the receiver to know <strong>Where</strong> they were hit (for blood splatters) or <strong>Who</strong> hit them (for kill credit). <code>FGameplayEffectContextHandle</code> is the suitcase that carries this extra data.</p>
                    
                    <h4>Data Extraction</h4>
                    <p>On the receiving end (e.g., in an AttributeSet or a GameplayCue), you can extract the hit result from the context to play a sound at the exact impact location or trigger a specific directional hit animation.</p>
                `,
                concepts: ["Metadata Passing", "Hit Attribution", "GAS Context"],
                practices: ["Always create a fresh context for new attacks", "Use for directional hit reactions", "Essential for 'Instigator' tracking"]
            },
            {
                id: 282,
                title: "ULocalPlayerSubsystem",
                category: "cat-subsystems",
                catName: "Subsystems",
                graph: `flowchart LR
                    Player[Human at PC] --> Sub[Local Player Subsystem]
                    Sub --> UI[Personal HUD Settings]
                    Sub --> Input[Input Remapping]`,
                code: `// --- UIPreferenceSubsystem.h ---
UCLASS()
class UUIPreferenceSubsystem : public ULocalPlayerSubsystem {
    GENERATED_BODY()
public:
    UPROPERTY()
    bool bInvertYAxis = false;
};

// --- Usage ---
UUIPreferenceSubsystem* Prefs = ULocalPlayer::GetSubsystem<UUIPreferenceSubsystem>(GetLocalPlayer());`,
                explanation: `
                    <h3>Per-Player Logic</h3>
                    <p>While <code>GameInstance</code> is global for the whole application, <code>ULocalPlayerSubsystem</code> is unique to each person playing. In a single-player game, there's only one, but it's the best place for player-specific settings like Input Inversion or UI scale.</p>
                    
                    <h4>UI Integration</h4>
                    <p>This is the perfect place to bridge C++ logic with UMG. Your HUD widgets can easily query this subsystem to see how they should be displayed without needing to talk to the GameMode or Character.</p>
                `,
                concepts: ["Personalization", "Input Settings", "Local Context"],
                practices: ["Use for player settings", "Use for local input remapping", "Survives level loads like GameInstanceSubsystem"]
            },
            {
                id: 283,
                title: "TSoftClassPtr (BP Loading)",
                category: "cat-assets",
                catName: "Assets",
                graph: `flowchart LR
                    Var[TSoftClassPtr] --"Wait"--> RAM[Empty]
                    Load[Async Load] --"Success"--> RAM[BP Class Ready]
                    RAM --"Spawn"--> Actor[Actor in World]`,
                code: `// --- Spawner.h ---
UPROPERTY(EditAnywhere, Category="Classes")
TSoftClassPtr<AActor> EnemyBP;

// --- Spawner.cpp ---
void ASpawner::Spawn() {
    if (EnemyBP.IsPending()) {
        UClass* LoadedClass = EnemyBP.LoadSynchronous();
        GetWorld()->SpawnActor<AActor>(LoadedClass, ...);
    }
}`,
                explanation: `
                    <h3>Referencing Blueprints Safely</h3>
                    <p>If you use <code>TSubclassOf&lt;AMyActor&gt;</code>, the engine will force-load that Blueprint into memory as soon as the spawner exists. If that Blueprint is large, your game will lag. <code>TSoftClassPtr</code> prevents this.</p>
                    
                    <h4>Why it matters</h4>
                    <p>In a large game with 100 different enemy types, you don't want all 100 Blueprints loaded at the same time. You use soft class pointers to only load the enemy type you are actually about to spawn.</p>
                `,
                concepts: ["Class Referencing", "Memory Optimization", "BP Performance"],
                practices: ["Use for all Blueprint class variables", "Use LoadSynchronous only for small classes", "Prefer Async loading for major characters"]
            },
            {
                id: 284,
                title: "FBox & FSphere Bounds",
                category: "cat-math",
                catName: "Math",
                graph: `flowchart LR
                    Bounds[FSphere Radius] --"Check"--> Point[My Location]
                    Point --"Result"--> Inside{Is Inside?}
                    Inside --"Yes"--> Play[Apply Effect]`,
                code: `// Check if a point is within a trigger sphere
FSphere DamageArea(GetActorLocation(), 500.f);
FVector EnemyLoc = Enemy->GetActorLocation();

if (DamageArea.IsInside(EnemyLoc)) {
    // Enemy is within 500 units
    DealDamage(Enemy);
}`,
                explanation: `
                    <h3>Primitive Containment</h3>
                    <p>Sometimes you don't need a full collision component. <code>FBox</code> and <code>FSphere</code> are lightweight mathematical shapes used to check if points or other shapes are overlapping.</p>
                    
                    <h4>Speed</h4>
                    <p>Checking <code>IsInside</code> on an <code>FSphere</code> is one of the fastest math operations in Unreal. It's just a simple distance check. Use this for quick proximity logic before doing more expensive line traces or physics sweeps.</p>
                `,
                concepts: ["Bounding Volumes", "Proximity Checks", "Geometry Math"],
                practices: ["Use for quick distance culling", "Use FBox for square areas", "Combine with physics for accurate results"]
            },
            {
                id: 285,
                title: "TFunctionRef (Efficiency)",
                category: "cat-events",
                catName: "Events",
                graph: `flowchart LR
                    Func[Heavy Loop] --"Uses"--> Callback[Small Lambda]
                    Callback --"No Memory Allocation"--> Fast[Extreme Performance]`,
                code: `// Function that takes a lambda as an argument
void ProcessActors(TFunctionRef<void(AActor*)> Callback) {
    for (AActor* A : AllActors) {
        Callback(A);
    }
}

// Usage
ProcessActors([](AActor* A){ 
    UE_LOG(LogTemp, Log, TEXT("Actor: %s"), *A->GetName()); 
});`,
                explanation: `
                    <h3>High-Performance Callbacks</h3>
                    <p>When you want to pass a <strong>Lambda</strong> into a function, <code>TFunctionRef</code> is the fastest way to do it. Unlike <code>TFunction</code>, it does not allocate memory on the heap.</p>
                    
                    <h4>The Catch</h4>
                    <p>Because it doesn't allocate memory, it is "Transient". You can only use it inside the function it was passed to. Never store a <code>TFunctionRef</code> as a class variableâ€”it will point to invalid memory once the function ends!</p>
                `,
                concepts: ["Lambda Optimization", "Stack vs Heap", "Functional C++"],
                practices: ["Use for temporary loops/filters", "Never store as a member variable", "Faster than standard Delegates for quick logic"]
            },
            {
                id: 286,
                title: "Static Mechanics",
                category: "cat-cpp",
                catName: "C++",
                graph: `flowchart LR
                    Obj1[Actor 1] --"Shared"--> Stat[Static Variable]
                    Obj2[Actor 2] --"Shared"--> Stat
                    Stat --"Common"--> Value[Global Counter]`,
                code: `// .h
class AMyActor : public AActor {
    static int32 GlobalActorCount; // Declared
};

// .cpp
int32 AMyActor::GlobalActorCount = 0; // Defined

AMyActor::AMyActor() {
    GlobalActorCount++; // All actors share this one number
}`,
                explanation: `
                    <h3>Shared Global State</h3>
                    <p>The <code>static</code> keyword in C++ means a variable or function belongs to the <strong>Class</strong> itself, rather than a specific instance. All 500 instances of <code>AMyActor</code> will share the exact same static variable.</p>
                    
                    <h4>Static Functions</h4>
                    <p>Static functions can be called without having an object (e.g., <code>UMyMath::CalculateResult()</code>). They are perfect for "Helper" or "Utility" libraries that don't need to store individual state.</p>
                `,
                concepts: ["Class Scope", "Global Helpers", "Memory Sharing"],
                practices: ["Use for Utility libraries", "Use for global counters (carefully)", "Note: Statics don't reset automatically on level load!"]
            },
            {
                id: 120,
                title: "TArray::FilterByPredicate",
                category: "cat-data",
                catName: "Data",
                graph: `flowchart LR
                    List[Big List of Actors] --"Lambda Logic"--> Filter[Filter]
                    Filter --"Keep if HP < 20"--> Result[Small List of Dying Actors]`,
                code: `TArray<AActor*> AllEnemies;
// ... populate array ...

// Find only enemies with low health
TArray<AActor*> WeakEnemies = AllEnemies.FilterByPredicate([](const AActor* Enemy){
    const IHealthInterface* HP = Cast<IHealthInterface>(Enemy);
    return HP && HP->GetHealth() < 20.0f;
});`,
                explanation: `
                    <h3>Smart List Filtering</h3>
                    <p>Instead of writing a long for-loop to find specific items in a list, <code>FilterByPredicate</code> allows you to do it in one line using a <strong>Lambda</strong>.</p>
                    
                    <h4>How it works</h4>
                    <p>The function goes through every item in the array. If the Lambda returns <code>true</code>, the item is added to the result. If <code>false</code>, it is skipped.</p>
                `,
                concepts: ["Functional Programming", "Collection Manipulation", "Lambdas"],
                practices: ["Use for complex searches", "Keep the lambda efficient", "Use const for the argument"]
            },
            {
                id: 121,
                title: "FTransform::InverseTransformPosition",
                category: "cat-math",
                catName: "Math",
                graph: `flowchart LR
                    World[World Location] --"Inverse Transform"--> Local[Relative to Actor]
                    Result["Example: '50 units to my left'"]`,
                code: `// Where is this explosion relative to the player?
FVector ExplosionWorldLoc = ...;
FVector RelativeLoc = GetActorTransform().InverseTransformPosition(ExplosionWorldLoc);

if (RelativeLoc.Y < 0) {
    UE_LOG(LogTemp, Log, TEXT("Explosion was on my LEFT side"));
}`,
                explanation: `
                    <h3>World to Local Conversion</h3>
                    <p>This function takes a point in the world and tells you where it is from the "Perspective" of an actor.</p>
                    
                    <h4>Usage</h4>
                    <p>Used heavily for <strong>Directional Indicators</strong> (the red arrows on screen when you take damage). By converting the hit location to a local position, you can easily tell if the hit came from the front, back, left, or right.</p>
                `,
                concepts: ["Coordinate Systems", "Relative Transformation", "Vector Basis"],
                practices: ["Use for directional UI", "Essential for local offset logic", "Combine with GetActorTransform()"]
            },
            {
                id: 122,
                title: "Forward Declarations",
                category: "cat-cpp",
                catName: "C++",
                graph: `flowchart LR
                    H[Header .h] --"class UCameraComponent;"--> Comp[Compiler]
                    Comp --"No Include Needed"--> Speed[Faster Compiles]
                    CPP[.cpp] --"#include CameraComponent.h"--> Logic[Full Access]`,
                code: `// --- MyActor.h ---
#pragma once
class UCameraComponent; // Forward Declaration

UCLASS()
class AMyActor : public AActor {
    UPROPERTY()
    TObjectPtr<UCameraComponent> Camera; // Valid!
};`,
                explanation: `
                    <h3>Optimization for Build Times</h3>
                    <p>In C++, whenever you <code>#include</code> a file, the compiler has to copy-paste the entire contents of that file. In large projects, this can lead to massive compile times.</p>
                    
                    <h4>The Rule of Thumb</h4>
                    <p>In your <strong>Header (.h)</strong>, never include another class header if you are only using a pointer or a reference. Just use <code>class UYourClassName;</code>. Then, in your <strong>Source (.cpp)</strong>, you can include the full header to use the functions of that class.</p>
                `,
                concepts: ["Compilation Performance", "Dependency Management", "C++ Linking"],
                practices: ["Always forward declare in headers", "Only include what you use", "Helps prevent Circular Dependencies"]
            }
        ];

        const allPieces = [...pieces, ...additionalPieces];

        function renderPieces(filter = 'all', searchTerm = '') {
            const grid = document.getElementById('legoGrid');
            grid.innerHTML = '';

            const filtered = allPieces.filter(p => {
                const matchesFilter = filter === 'all' || p.category === filter;
                const matchesSearch = p.title.toLowerCase().includes(searchTerm.toLowerCase()) || 
                                     (p.pseudo && p.pseudo.toLowerCase().includes(searchTerm.toLowerCase()));
                return matchesFilter && matchesSearch;
            });

            filtered.forEach(p => {
                const card = document.createElement('div');
                card.className = `lego-card ${p.category}`;
                card.onclick = () => showDetail(p.id);
                card.innerHTML = `
                    <div class="card-header">
                        <span class="card-title">${p.title}</span>
                        <span class="card-category">${p.catName}</span>
                    </div>
                    <div class="card-body">
                        <div class="mini-graph">
                            <pre class="mermaid">${p.graph}</pre>
                        </div>
                        <div class="code-block">
                            <pre><code>${escapeHtml(p.code)}</code></pre>
                        </div>
                        <div class="pseudo-code">
                            <strong>How it works:</strong>
                            ${p.pseudo ? p.pseudo.substring(0, 120) + (p.pseudo.length > 120 ? '...' : '') : 
                             (p.explanation ? p.explanation.replace(/<[^>]*>/g, '').substring(0, 120) + '...' : '')}
                        </div>
                    </div>
                `;
                grid.appendChild(card);
            });

            mermaid.run();
        }

        function showDetail(id) {
            const p = allPieces.find(x => x.id === id);
            if (!p) return;

            const detailView = document.getElementById('detailView');
            const detailContent = document.getElementById('detailContent');
            
            detailContent.innerHTML = `
                <div class="detail-header">
                    <span class="detail-category">${p.catName}</span>
                    <h2>${p.title}</h2>
                </div>
                
                <div class="detail-section">
                    <span class="section-label">Architecture Diagram</span>
                    <div class="detail-mermaid">
                        <pre class="mermaid">${p.graph}</pre>
                    </div>
                </div>

                <div class="detail-section">
                    <span class="section-label">Implementation Example</span>
                    <div class="detail-code-container">
                        <div class="code-header-bar">
                            <span>Unreal Engine C++</span>
                            <span style="cursor:pointer" onclick="copyToClipboard(this, ${p.id})">Copy Snippet</span>
                        </div>
                        <pre class="detail-code"><code>${escapeHtml(p.code)}</code></pre>
                    </div>
                </div>

                <div class="detail-section">
                    <span class="section-label">Deep Explanation</span>
                    <div class="detail-explanation">
                        <div class="explanation-text">
                            ${p.explanation || (p.pseudo ? `<p>${p.pseudo}</p>` : 'Detailed explanation coming soon...')}
                        </div>
                        <div class="info-grid">
                            <div class="info-card">
                                <h4>Key Concepts</h4>
                                <ul>
                                    ${(p.concepts || ['UE5 Architecture Standard', 'Memory Management Safety', 'Blueprint Compatibility']).map(c => `<li>${c}</li>`).join('')}
                                </ul>
                            </div>
                            <div class="info-card">
                                <h4>Best Practices</h4>
                                <ul>
                                    ${(p.practices || ['Always call Super::', 'Check for null pointers', 'Use TObjectPtr for properties']).map(b => `<li>${b}</li>`).join('')}
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            detailView.style.display = 'block';
            document.body.style.overflow = 'hidden';
            
            if (window.location.hash !== `#piece-${p.id}`) {
                history.pushState({pieceId: p.id}, p.title, `#piece-${p.id}`);
            }

            mermaid.init(undefined, '.detail-mermaid .mermaid');
        }

        function closeDetail() {
            document.getElementById('detailView').style.display = 'none';
            document.body.style.overflow = 'auto';
            if (window.location.hash) {
                history.pushState("", document.title, window.location.pathname + window.location.search);
            }
        }

        window.onpopstate = function(event) {
            if (event.state && event.state.pieceId) {
                showDetail(event.state.pieceId);
            } else {
                closeDetail();
            }
        };

        function escapeHtml(unsafe) {
            return unsafe
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
        }

        function copyToClipboard(btn, id) {
            const p = allPieces.find(x => x.id == id);
            navigator.clipboard.writeText(p.code);
            const originalText = btn.innerText;
            btn.innerText = "Copied!";
            setTimeout(() => btn.innerText = originalText, 2000);
        }

        // Search Listener
        document.getElementById('searchInput').addEventListener('input', (e) => {
            const activeFilter = document.querySelector('.filter-btn.active').dataset.filter;
            renderPieces(activeFilter, e.target.value);
        });

        // Filter Listeners
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                const searchTerm = document.getElementById('searchInput').value;
                renderPieces(btn.dataset.filter, searchTerm);
            });
        });

        // Initial Render
        renderPieces();

    </script>
</body>
</html>